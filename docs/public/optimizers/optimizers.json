{
  "version": "1.0.0",
  "generated": "auto-generated by scripts/generate_docs.py",
  "total_count": 56,
  "optimizers": [
    {
      "name": "African Buffalo Optimizer",
      "class_name": "AfricanBuffaloOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "african-buffalo",
      "link": "/algorithms/swarm-intelligence/african-buffalo",
      "description": "African Buffalo Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "lp1",
          "type": "float",
          "default": "_LP1",
          "required": false,
          "description": "Learning parameter 1 controlling exploitation strength."
        },
        {
          "name": "lp2",
          "type": "float",
          "default": "_LP2",
          "required": false,
          "description": "Learning parameter 2 controlling exploration strength."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.african_buffalo_optimization import AfricanBuffaloOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AfricanBuffaloOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "African Vultures Optimizer",
      "class_name": "AfricanVulturesOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "african-vultures",
      "link": "/algorithms/swarm-intelligence/african-vultures",
      "description": "African Vultures Optimization Algorithm (AVOA).",
      "reference": "Abdollahzadeh, B., Soleimanian Gharehchopogh, F., & Mirjalili, S. (2021).\n    African vultures optimization algorithm: A new nature-inspired\n    metaheuristic algorithm for global optimization problems.\n    Computers & Industrial Engineering, 158, 107408.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.african_vultures_optimizer import AfricanVulturesOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AfricanVulturesOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Ant Colony Optimization",
      "class_name": "AntColony",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "ant-colony",
      "link": "/algorithms/swarm-intelligence/ant-colony",
      "description": "Ant Colony Optimization (ACO) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of ants in colony."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "alpha",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Pheromone influence exponent."
        },
        {
          "name": "beta",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Heuristic information weight (not used in basic\n        continuous ACO)."
        },
        {
          "name": "rho",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Pheromone evaporation rate in [0, 1]."
        },
        {
          "name": "q",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Pheromone deposit constant."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = AntColony(func=objective_function, lower_bound=-10, upper_bound=10,\n    dim=2, n_ants=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Ant Lion Optimizer",
      "class_name": "AntLionOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "ant-lion",
      "link": "/algorithms/swarm-intelligence/ant-lion",
      "description": "Ant Lion Optimizer (ALO) Algorithm.",
      "reference": "Mirjalili, S. (2015). The Ant Lion Optimizer.\n    Advances in Engineering Software, 83, 80-98.\n    DOI: 10.1016/j.advengsoft.2015.01.010",
      "reference_doi": "10.1016/j.advengsoft.2015.01.010",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking for BBOB\n        post-processing."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = AntLionOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Aquila Optimizer",
      "class_name": "AquilaOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "aquila",
      "link": "/algorithms/swarm-intelligence/aquila",
      "description": "Aquila Optimizer (AO).",
      "reference": "Abualigah, L., Yousri, D., Abd Elaziz, M., Ewees, A. A., Al-qaness, M. A.,\n    & Gandomi, A. H. (2021). Aquila optimizer: A novel meta-heuristic\n    optimization algorithm.\n    Computers & Industrial Engineering, 157, 107250.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.aquila_optimizer import AquilaOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AquilaOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Artificial Fish Swarm",
      "class_name": "ArtificialFishSwarm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-fish-swarm",
      "link": "/algorithms/swarm-intelligence/artificial-fish-swarm",
      "description": "Artificial Fish Swarm Algorithm (AFSA).",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "fish_swarm",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of fish in swarm."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "visual",
          "type": "int",
          "default": "1",
          "required": false,
          "description": "Visual distance parameter."
        },
        {
          "name": "step",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Step size parameter."
        },
        {
          "name": "try_number",
          "type": "int",
          "default": "3",
          "required": false,
          "description": "Number of attempts."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-09",
          "required": false,
          "description": "Small value for numerical stability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.artificial_fish_swarm_algorithm import ArtificialFishSwarm\n    optimizer = ArtificialFishSwarm(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, n_fish=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Artificial Gorilla Troops Optimizer",
      "class_name": "ArtificialGorillaTroopsOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-gorilla-troops",
      "link": "/algorithms/swarm-intelligence/artificial-gorilla-troops",
      "description": "Artificial Gorilla Troops Optimizer (GTO).",
      "reference": "Abdollahzadeh, B., Soleimanian Gharehchopogh, F., & Mirjalili, S. (2021).\n    Artificial gorilla troops optimizer: A new nature-inspired metaheuristic\n    algorithm for global optimization problems.\n    International Journal of Intelligent Systems, 36(10), 5887-5958.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.artificial_gorilla_troops import (\n    ArtificialGorillaTroopsOptimizer,\n)\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ArtificialGorillaTroopsOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Artificial Hummingbird Algorithm",
      "class_name": "ArtificialHummingbirdAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-hummingbird",
      "link": "/algorithms/swarm-intelligence/artificial-hummingbird",
      "description": "Artificial Hummingbird Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.artificial_hummingbird import ArtificialHummingbirdAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ArtificialHummingbirdAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Artificial Rabbits Optimizer",
      "class_name": "ArtificialRabbitsOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-rabbits",
      "link": "/algorithms/swarm-intelligence/artificial-rabbits",
      "description": "Artificial Rabbits Optimization (ARO) Algorithm.",
      "reference": "Wang, L., Cao, Q., Zhang, Z., Mirjalili, S., & Zhao, W. (2022).\n    Artificial rabbits optimization: A new bio-inspired meta-heuristic\n    algorithm for solving engineering optimization problems.\n    Engineering Applications of Artificial Intelligence, 114, 105082.\n    DOI: 10.1016/j.engappai.2022.105082",
      "reference_doi": "10.1016/j.engappai.2022.105082",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = ArtificialRabbitsOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Barnacles Mating Optimizer",
      "class_name": "BarnaclesMatingOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "barnacles-mating",
      "link": "/algorithms/swarm-intelligence/barnacles-mating",
      "description": "Barnacles Mating Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "pl",
          "type": "int",
          "default": "_PL",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.barnacles_mating import BarnaclesMatingOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BarnaclesMatingOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Bat Algorithm",
      "class_name": "BatAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "bat",
      "link": "/algorithms/swarm-intelligence/bat",
      "description": "Bat Algorithm optimization algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "n_bats",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Number of bats in the population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "loudness",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Initial loudness parameter (0-1)."
        },
        {
          "name": "pulse_rate",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Pulse emission rate (0-1)."
        },
        {
          "name": "freq_min",
          "type": "float",
          "default": "0",
          "required": false,
          "description": "Minimum frequency for velocity updates."
        },
        {
          "name": "freq_max",
          "type": "float",
          "default": "2",
          "required": false,
          "description": "Maximum frequency for velocity updates."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "import numpy as np\n    from opt.benchmark.functions import shifted_ackley\n    from opt.bat_algorithm import BatAlgorithm\n\n    # Define the objective function\n    def objective_function(x):\n        return np.sum(x ** 2)\n\n    # Create an instance of the BatAlgorithm class\n    optimizer = BatAlgorithm(\n        func=objective_function,\n        dim=2,\n        lower_bound=-5.0,\n        upper_bound=5.0,\n        n_bats=10,\n        max_iter=1000,\n        loudness=0.5,\n        pulse_rate=0.9,\n        freq_min=0,\n        freq_max=2\n    )\n\n    # Run the Bat Algorithm optimization\n    best_solution, best_fitness = optimizer.search()\n\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness value: {best_fitness}\")"
    },
    {
      "name": "Bee Algorithm",
      "class_name": "BeeAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "bee",
      "link": "/algorithms/swarm-intelligence/bee",
      "description": "Bee Algorithm optimizer implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "n_bees",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of bees in population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "scout_bee",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Scout bee ratio."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.bee_algorithm import BeeAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BeeAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Black Widow Optimizer",
      "class_name": "BlackWidowOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "black-widow",
      "link": "/algorithms/swarm-intelligence/black-widow",
      "description": "Black Widow Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "pp",
          "type": "float",
          "default": "_PP",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "cr",
          "type": "float",
          "default": "_CR",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "pm",
          "type": "float",
          "default": "_PM",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.black_widow import BlackWidowOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BlackWidowOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Brown Bear Optimizer",
      "class_name": "BrownBearOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "brown-bear",
      "link": "/algorithms/swarm-intelligence/brown-bear",
      "description": "Brown Bear Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.brown_bear import BrownBearOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BrownBearOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Cat Swarm Optimization",
      "class_name": "CatSwarmOptimization",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "cat-swarm",
      "link": "/algorithms/swarm-intelligence/cat-swarm",
      "description": "Cat Swarm Optimization (CSO) algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "cats",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of cats in population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seeking_memory_pool",
          "type": "int",
          "default": "5",
          "required": false,
          "description": "Memory pool size for seeking mode."
        },
        {
          "name": "counts_of_dimension_to_change",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Dimensions to change."
        },
        {
          "name": "smp_change_probability",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "SMP change probability."
        },
        {
          "name": "spc_probability",
          "type": "float",
          "default": "0.2",
          "required": false,
          "description": "SPC probability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.cat_swarm_optimization import CatSwarmOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CatSwarmOptimization(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Chimp Optimization Algorithm",
      "class_name": "ChimpOptimizationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "chimp",
      "link": "/algorithms/swarm-intelligence/chimp",
      "description": "Chimp Optimization Algorithm (ChOA) implementation.",
      "reference": "Khishe, M., & Mosavi, M. R. (2020). Chimp optimization algorithm.\n    Expert Systems with Applications, 149, 113338.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.chimp_optimization import ChimpOptimizationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ChimpOptimizationAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Coati Optimizer",
      "class_name": "CoatiOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "coati",
      "link": "/algorithms/swarm-intelligence/coati",
      "description": "Coati Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.coati_optimizer import CoatiOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CoatiOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Cuckoo Search",
      "class_name": "CuckooSearch",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "cuckoo",
      "link": "/algorithms/swarm-intelligence/cuckoo",
      "description": "Cuckoo Search Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of nests (solutions) in the population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "mutation_probability",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Probability of abandoning a nest\n        (discovery rate pa)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = CuckooSearch(func=objective_function, lower_bound=-10, upper_bound=10,\n    dim=2, n_nests=25, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Dandelion Optimizer",
      "class_name": "DandelionOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "dandelion",
      "link": "/algorithms/swarm-intelligence/dandelion",
      "description": "Dandelion Optimizer (DO).",
      "reference": "Zhao, S., Zhang, T., Ma, S., & Chen, M. (2022).\n    Dandelion Optimizer: A nature-inspired metaheuristic algorithm for\n    engineering applications.\n    Engineering Applications of Artificial Intelligence, 114, 105075.\n    DOI: 10.1016/j.engappai.2022.105075",
      "reference_doi": "10.1016/j.engappai.2022.105075",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = DandelionOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Dingo Optimizer",
      "class_name": "DingoOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "dingo",
      "link": "/algorithms/swarm-intelligence/dingo",
      "description": "Dingo Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "survival_rate",
          "type": "float",
          "default": "_SURVIVAL_RATE",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.dingo_optimizer import DingoOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = DingoOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Dragonfly Optimizer",
      "class_name": "DragonflyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "dragonfly",
      "link": "/algorithms/swarm-intelligence/dragonfly",
      "description": "Dragonfly Algorithm (DA).",
      "reference": "Mirjalili, S. (2016). Dragonfly algorithm: a new meta-heuristic optimization\n    technique for solving single-objective, discrete, and multi-objective problems.\n    Neural Computing and Applications, 27(4), 1053-1073.\n    DOI: 10.1007/s00521-015-1920-1",
      "reference_doi": "10.1007/s00521-015-1920-1",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of dragonflies in swarm."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = DragonflyOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Emperor Penguin Optimizer",
      "class_name": "EmperorPenguinOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "emperor-penguin",
      "link": "/algorithms/swarm-intelligence/emperor-penguin",
      "description": "Emperor Penguin Optimizer (EPO) implementation.",
      "reference": "Dhiman, G., & Kumar, V. (2018). Emperor penguin optimizer: A bio-inspired\n    algorithm for engineering problems. Knowledge-Based Systems, 159, 20-50.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.emperor_penguin import EmperorPenguinOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = EmperorPenguinOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Fennec Fox Optimizer",
      "class_name": "FennecFoxOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "fennec-fox",
      "link": "/algorithms/swarm-intelligence/fennec-fox",
      "description": "Fennec Fox Optimization (FFO) Algorithm.",
      "reference": "Trojovsk\u00e1, E., Dehghani, M., & Trojovsk\u00fd, P. (2023).\n    Fennec Fox Optimization: A New Nature-Inspired Optimization Algorithm.\n    IEEE Access, 10, 84417-84443.\n    DOI: 10.1109/ACCESS.2022.3197745",
      "reference_doi": "10.1109/ACCESS.2022.3197745",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = FennecFoxOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Firefly Algorithm",
      "class_name": "FireflyAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "firefly",
      "link": "/algorithms/swarm-intelligence/firefly",
      "description": "Firefly Algorithm implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of fireflies in the population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "alpha",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Randomization parameter controlling step size\n        of random movement."
        },
        {
          "name": "beta_0",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Attractiveness coefficient at distance r=0."
        },
        {
          "name": "gamma",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Light absorption coefficient."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.firefly_algorithm import FireflyAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = FireflyAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Flower Pollination Algorithm",
      "class_name": "FlowerPollinationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "flower-pollination",
      "link": "/algorithms/swarm-intelligence/flower-pollination",
      "description": "Flower Pollination Algorithm (FPA) implementation.",
      "reference": "Yang, X.-S. (2012). Flower pollination algorithm for global optimization.\n    In Unconventional Computation and Natural Computation (pp. 240-249).\n    Springer.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "25",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "switch_probability",
          "type": "float",
          "default": "_SWITCH_PROBABILITY",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.flower_pollination import FlowerPollinationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = FlowerPollinationAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Giant Trevally Optimizer",
      "class_name": "GiantTrevallyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "giant-trevally",
      "link": "/algorithms/swarm-intelligence/giant-trevally",
      "description": "Giant Trevally Optimizer (GTO).",
      "reference": "Sadeeq, H. T., & Abdulazeez, A. M. (2022).\n    Giant Trevally Optimizer (GTO): A Novel Metaheuristic Algorithm for\n    Global Optimization and Challenging Engineering Problems.\n    IEEE Access, 10, 121615-121640.\n    DOI: 10.1109/ACCESS.2022.3223388",
      "reference_doi": "10.1109/ACCESS.2022.3223388",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = GiantTrevallyOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Glowworm Swarm Optimization",
      "class_name": "GlowwormSwarmOptimization",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "glowworm-swarm",
      "link": "/algorithms/swarm-intelligence/glowworm-swarm",
      "description": "Glowworm Swarm Optimization (GSO) algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of glowworms."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "luciferin_decay",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Luciferin decay constant."
        },
        {
          "name": "randomness",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Randomness factor in movement."
        },
        {
          "name": "step_size",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Movement step size."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.glowworm_swarm_optimization import GlowwormSwarmOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = GlowwormSwarmOptimization(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Golden Eagle Optimizer",
      "class_name": "GoldenEagleOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "golden-eagle",
      "link": "/algorithms/swarm-intelligence/golden-eagle",
      "description": "Golden Eagle Optimizer (GEO) implementation.",
      "reference": "Mohammadi-Balani, A., Nayeri, M. D., Azar, A., & Taghizadeh-Yazdi, M.\n    (2021). Golden eagle optimizer: A nature-inspired metaheuristic algorithm.\n    Computers & Industrial Engineering, 152, 107050.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.golden_eagle import GoldenEagleOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = GoldenEagleOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Grasshopper Optimizer",
      "class_name": "GrasshopperOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "grasshopper",
      "link": "/algorithms/swarm-intelligence/grasshopper",
      "description": "Grasshopper Optimization Algorithm (GOA).",
      "reference": "Saremi, S., Mirjalili, S., & Lewis, A. (2017). Grasshopper Optimisation\n    Algorithm: Theory and application. Advances in Engineering Software,\n    105, 30-47. DOI: 10.1016/j.advengsoft.2017.01.004",
      "reference_doi": "10.1016/j.advengsoft.2017.01.004",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of grasshoppers."
        },
        {
          "name": "c_max",
          "type": "float",
          "default": "_C_MAX",
          "required": false,
          "description": "Maximum coefficient for social forces."
        },
        {
          "name": "c_min",
          "type": "float",
          "default": "_C_MIN",
          "required": false,
          "description": "Minimum coefficient for social forces."
        },
        {
          "name": "f",
          "type": "float",
          "default": "_ATTRACTION_INTENSITY",
          "required": false,
          "description": "Attraction intensity in social force function."
        },
        {
          "name": "l",
          "type": "float",
          "default": "_ATTRACTIVE_LENGTH_SCALE",
          "required": false,
          "description": "Attractive length scale in social force function."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = GrasshopperOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Grey Wolf Optimizer",
      "class_name": "GreyWolfOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "grey-wolf",
      "link": "/algorithms/swarm-intelligence/grey-wolf",
      "description": "Grey Wolf Optimizer (GWO) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Pack size (number of wolves)."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = GreyWolfOptimizer(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, pack_size=20, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Harris Hawks Optimizer",
      "class_name": "HarrisHawksOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "harris-hawks",
      "link": "/algorithms/swarm-intelligence/harris-hawks",
      "description": "Harris Hawks Optimization (HHO) Algorithm.",
      "reference": "Heidari, A.A., Mirjalili, S., Faris, H., Aljarah, I., Mafarja, M., & Chen, H.\n    (2019). Harris hawks optimization: Algorithm and applications.\n    Future Generation Computer Systems, 97, 849-872.\n    DOI: 10.1016/j.future.2019.02.028",
      "reference_doi": "10.1016/j.future.2019.02.028",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of hawks."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = HarrisHawksOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Honey Badger Algorithm",
      "class_name": "HoneyBadgerAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "honey-badger",
      "link": "/algorithms/swarm-intelligence/honey-badger",
      "description": "Honey Badger Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "beta",
          "type": "float",
          "default": "_BETA",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.honey_badger import HoneyBadgerAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = HoneyBadgerAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Manta Ray Foraging Optimization",
      "class_name": "MantaRayForagingOptimization",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "manta-ray-foraging",
      "link": "/algorithms/swarm-intelligence/manta-ray-foraging",
      "description": "Manta Ray Foraging Optimization (MRFO) implementation.",
      "reference": "Zhao, W., Zhang, Z., & Wang, L. (2020). Manta ray foraging optimization:\n    An effective bio-inspired optimizer for engineering applications.\n    Engineering Applications of Artificial Intelligence, 87, 103300.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.manta_ray import MantaRayForagingOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MantaRayForagingOptimization(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Marine Predators Optimizer",
      "class_name": "MarinePredatorsOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "marine-predators",
      "link": "/algorithms/swarm-intelligence/marine-predators",
      "description": "Marine Predators Algorithm (MPA).",
      "reference": "Faramarzi, A., Heidarinejad, M., Mirjalili, S., & Gandomi, A. H. (2020).\n    Marine Predators Algorithm: A nature-inspired metaheuristic.\n    Expert Systems with Applications, 152, 113377.\n    DOI: 10.1016/j.eswa.2020.113377",
      "reference_doi": "10.1016/j.eswa.2020.113377",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of predators/prey."
        },
        {
          "name": "fads",
          "type": "float",
          "default": "_FADs_EFFECT_PROB",
          "required": false,
          "description": "Fish Aggregating Devices effect probability."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = MarinePredatorsOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Mayfly Optimizer",
      "class_name": "MayflyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "mayfly",
      "link": "/algorithms/swarm-intelligence/mayfly",
      "description": "Mayfly Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "a1",
          "type": "float",
          "default": "_A1",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "a2",
          "type": "float",
          "default": "_A2",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "a3",
          "type": "float",
          "default": "_A3",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "beta",
          "type": "float",
          "default": "_BETA",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "dance",
          "type": "float",
          "default": "_DANCE",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "fl",
          "type": "float",
          "default": "_FL",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "g",
          "type": "float",
          "default": "_G",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.mayfly_optimizer import MayflyOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MayflyOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Moth Flame Optimizer",
      "class_name": "MothFlameOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "moth-flame",
      "link": "/algorithms/swarm-intelligence/moth-flame",
      "description": "Moth-Flame Optimization (MFO) Algorithm.",
      "reference": "Mirjalili, S. (2015). Moth-flame optimization algorithm: A novel nature-inspired\n    heuristic paradigm. Knowledge-Based Systems, 89, 228-249.\n    DOI: 10.1016/j.knosys.2015.07.006",
      "reference_doi": "10.1016/j.knosys.2015.07.006",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of moths/flames."
        },
        {
          "name": "b",
          "type": "float",
          "default": "1.0",
          "required": false,
          "description": "Spiral shape constant."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = MothFlameOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Moth Search Algorithm",
      "class_name": "MothSearchAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "moth",
      "link": "/algorithms/swarm-intelligence/moth",
      "description": "Moth Search Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "path_finder_ratio",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.moth_search import MothSearchAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MothSearchAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Mountain Gazelle Optimizer",
      "class_name": "MountainGazelleOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "mountain-gazelle",
      "link": "/algorithms/swarm-intelligence/mountain-gazelle",
      "description": "Mountain Gazelle Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.mountain_gazelle import MountainGazelleOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MountainGazelleOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Orca Predator Algorithm",
      "class_name": "OrcaPredatorAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "orca-predator",
      "link": "/algorithms/swarm-intelligence/orca-predator",
      "description": "Orca Predator Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.orca_predator import OrcaPredatorAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = OrcaPredatorAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Osprey Optimizer",
      "class_name": "OspreyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "osprey",
      "link": "/algorithms/swarm-intelligence/osprey",
      "description": "Osprey Optimization Algorithm (OOA).",
      "reference": "Dehghani, M., Trojovsk\u00fd, P., & Hub\u00e1lovsk\u00fd, \u0160. (2023).\n    Osprey optimization algorithm: A new bio-inspired metaheuristic algorithm\n    for solving engineering optimization problems.\n    Frontiers in Mechanical Engineering, 8, 1126450.\n    DOI: 10.3389/fmech.2022.1126450",
      "reference_doi": "10.3389/fmech.2022.1126450",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = OspreyOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Particle Swarm Optimization",
      "class_name": "ParticleSwarm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "particle-swarm",
      "link": "/algorithms/swarm-intelligence/particle-swarm",
      "description": "Particle Swarm Optimization (PSO) algorithm implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "DEFAULT_POPULATION_SIZE",
          "required": false,
          "description": "Number of particles in swarm."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "DEFAULT_MAX_ITERATIONS",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "c1",
          "type": "float",
          "default": "PSO_COGNITIVE_COEFFICIENT",
          "required": false,
          "description": "Cognitive coefficient controlling attraction to personal\n        best."
        },
        {
          "name": "c2",
          "type": "float",
          "default": "PSO_SOCIAL_COEFFICIENT",
          "required": false,
          "description": "Social coefficient controlling attraction to global best."
        },
        {
          "name": "w",
          "type": "float",
          "default": "PSO_INERTIA_WEIGHT",
          "required": false,
          "description": "Inertia weight controlling previous velocity influence."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking for BBOB\n        post-processing."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.particle_swarm import ParticleSwarm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ParticleSwarm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Pathfinder Algorithm",
      "class_name": "PathfinderAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "pathfinder",
      "link": "/algorithms/swarm-intelligence/pathfinder",
      "description": "Pathfinder Algorithm (PFA) implementation.",
      "reference": "Yapici, H., & Cetinkaya, N. (2019). A new meta-heuristic optimizer:\n    Pathfinder algorithm. Applied Soft Computing, 78, 545-568.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.pathfinder import PathfinderAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = PathfinderAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Pelican Optimizer",
      "class_name": "PelicanOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "pelican",
      "link": "/algorithms/swarm-intelligence/pelican",
      "description": "Pelican Optimization Algorithm (POA).",
      "reference": "Trojovsk\u00fd, P., & Dehghani, M. (2022).\n    Pelican Optimization Algorithm: A Novel Nature-Inspired Algorithm for\n    Engineering Applications.\n    Sensors, 22(3), 855.\n    DOI: 10.3390/s22030855",
      "reference_doi": "10.3390/s22030855",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = PelicanOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Reptile Search Algorithm",
      "class_name": "ReptileSearchAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "reptile",
      "link": "/algorithms/swarm-intelligence/reptile",
      "description": "Reptile Search Algorithm (RSA) implementation.",
      "reference": "Abualigah, L., Abd Elaziz, M., Sumari, P., Geem, Z. W., & Gandomi, A. H.\n    (2022). Reptile Search Algorithm (RSA): A nature-inspired meta-heuristic\n    optimizer. Expert Systems with Applications, 191, 116158.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.reptile_search import ReptileSearchAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ReptileSearchAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Salp Swarm Optimizer",
      "class_name": "SalpSwarmOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "salp-swarm",
      "link": "/algorithms/swarm-intelligence/salp-swarm",
      "description": "Salp Swarm Algorithm (SSA).",
      "reference": "Mirjalili, S., Gandomi, A. H., Mirjalili, S. Z., Saremi, S., Faris, H., &\n    Mirjalili, S. M. (2017). Salp Swarm Algorithm: A bio-inspired optimizer for\n    engineering design problems. Advances in Engineering Software, 114, 163-191.\n    DOI: 10.1016/j.advengsoft.2017.07.002",
      "reference_doi": "10.1016/j.advengsoft.2017.07.002",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of salps in the chain."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SalpSwarmOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Sand Cat Swarm Optimizer",
      "class_name": "SandCatSwarmOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "sand-cat-swarm",
      "link": "/algorithms/swarm-intelligence/sand-cat-swarm",
      "description": "Sand Cat Swarm Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.sand_cat import SandCatSwarmOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SandCatSwarmOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Seagull Optimization Algorithm",
      "class_name": "SeagullOptimizationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "seagull",
      "link": "/algorithms/swarm-intelligence/seagull",
      "description": "Seagull Optimization Algorithm (SOA) implementation.",
      "reference": "Dhiman, G., & Kumar, V. (2019). Seagull optimization algorithm: Theory\n    and its applications for large-scale industrial engineering problems.\n    Knowledge-Based Systems, 165, 169-196.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.seagull_optimization import SeagullOptimizationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SeagullOptimizationAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Slime Mould Algorithm",
      "class_name": "SlimeMouldAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "slime-mould",
      "link": "/algorithms/swarm-intelligence/slime-mould",
      "description": "Slime Mould Algorithm (SMA) implementation.",
      "reference": "Li, S., Chen, H., Wang, M., Heidari, A. A., & Mirjalili, S. (2020).\n    Slime mould algorithm: A new method for stochastic optimization.\n    Future Generation Computer Systems, 111, 300-323.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.slime_mould import SlimeMouldAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SlimeMouldAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Snow Geese Optimizer",
      "class_name": "SnowGeeseOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "snow-geese",
      "link": "/algorithms/swarm-intelligence/snow-geese",
      "description": "Snow Geese Optimization Algorithm (SGOA).",
      "reference": "Jiang, H., Yang, Y., Ping, W., & Dong, Y. (2023).\n    A novel hybrid algorithm based on Snow Geese and Differential Evolution\n    for global optimization.\n    Applied Soft Computing, 139, 110235.\n    DOI: 10.1016/j.asoc.2023.110235",
      "reference_doi": "10.1016/j.asoc.2023.110235",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SnowGeeseOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Spotted Hyena Optimizer",
      "class_name": "SpottedHyenaOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "spotted-hyena",
      "link": "/algorithms/swarm-intelligence/spotted-hyena",
      "description": "Spotted Hyena Optimizer (SHO) implementation.",
      "reference": "Dhiman, G., & Kumar, V. (2017). Spotted hyena optimizer: A novel\n    bio-inspired based metaheuristic technique for engineering applications.\n    Advances in Engineering Software, 114, 48-70.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.spotted_hyena import SpottedHyenaOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SpottedHyenaOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Squirrel Search Algorithm",
      "class_name": "SquirrelSearchAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "squirrel",
      "link": "/algorithms/swarm-intelligence/squirrel",
      "description": "Squirrel Search Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking for BBOB\n        post-processing."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.squirrel_search import SquirrelSearchAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SquirrelSearchAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Starling Murmuration Optimizer",
      "class_name": "StarlingMurmurationOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "starling-murmuration",
      "link": "/algorithms/swarm-intelligence/starling-murmuration",
      "description": "Starling Murmuration Optimizer (SMO).",
      "reference": "Zamani, H., Nadimi-Shahraki, M. H., & Gandomi, A. H. (2022).\n    Starling murmuration optimizer: A novel bio-inspired algorithm for\n    global and engineering optimization.\n    Computer Methods in Applied Mechanics and Engineering, 392, 114616.\n    DOI: 10.1016/j.cma.2022.114616",
      "reference_doi": "10.1016/j.cma.2022.114616",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = StarlingMurmurationOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Tunicate Swarm Algorithm",
      "class_name": "TunicateSwarmAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "tunicate-swarm",
      "link": "/algorithms/swarm-intelligence/tunicate-swarm",
      "description": "Tunicate Swarm Algorithm (TSA) implementation.",
      "reference": "Kaur, S., Awasthi, L. K., Sangal, A. L., & Dhiman, G. (2020). Tunicate\n    Swarm Algorithm: A new bio-inspired based metaheuristic paradigm for\n    global optimization. Engineering Applications of Artificial Intelligence,\n    90, 103541.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.tunicate_swarm import TunicateSwarmAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = TunicateSwarmAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Whale Optimization Algorithm",
      "class_name": "WhaleOptimizationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "whale",
      "link": "/algorithms/swarm-intelligence/whale",
      "description": "Whale Optimization Algorithm (WOA).",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of whales."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = WhaleOptimizationAlgorithm(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, n_whales=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Wild Horse Optimizer",
      "class_name": "WildHorseOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "wild-horse",
      "link": "/algorithms/swarm-intelligence/wild-horse",
      "description": "Wild Horse Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "n_groups",
          "type": "int",
          "default": "5",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.wild_horse import WildHorseOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = WildHorseOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Zebra Optimizer",
      "class_name": "ZebraOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "zebra",
      "link": "/algorithms/swarm-intelligence/zebra",
      "description": "Zebra Optimization Algorithm (ZOA).",
      "reference": "Trojovsk\u00e1, E., Dehghani, M., & Trojovsk\u00fd, P. (2022).\n    Zebra Optimization Algorithm: A New Bio-Inspired Optimization Algorithm\n    for Solving Optimization Problems.\n    IEEE Access, 10, 49445-49473.\n    DOI: 10.1109/ACCESS.2022.3172789",
      "reference_doi": "10.1109/ACCESS.2022.3172789",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = ZebraOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    }
  ]
}