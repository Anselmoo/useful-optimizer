{
  "version": "1.0.0",
  "generated": "auto-generated by scripts/generate_docs.py",
  "total_count": 117,
  "optimizers": [
    {
      "name": "BFGS",
      "class_name": "BFGS",
      "category": "classical",
      "category_display": "Classical",
      "slug": "bfgs",
      "link": "/algorithms/classical/bfgs",
      "description": "BFGS Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per restart."
        },
        {
          "name": "num_restarts",
          "type": "int",
          "default": "25",
          "required": false,
          "description": "Number of random restarts for multistart strategy."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = BFGS(func=objective_function, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Conjugate Gradient",
      "class_name": "ConjugateGradient",
      "category": "classical",
      "category_display": "Classical",
      "slug": "conjugate-gradient",
      "link": "/algorithms/classical/conjugate-gradient",
      "description": "Conjugate Gradient Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per restart."
        },
        {
          "name": "num_restarts",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of random restarts for multistart strategy."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = ConjugateGradient(func=objective_function, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Hill Climbing",
      "class_name": "HillClimbing",
      "category": "classical",
      "category_display": "Classical",
      "slug": "hill-climbing",
      "link": "/algorithms/classical/hill-climbing",
      "description": "Hill Climbing optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "initial_step_sizes",
          "type": "float",
          "default": "1.0",
          "required": false,
          "description": "Initial step size for all dimensions."
        },
        {
          "name": "acceleration",
          "type": "float",
          "default": "1.2",
          "required": false,
          "description": "Factor for step size adaptation."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-06",
          "required": false,
          "description": "Convergence threshold for fitness change."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.classical.hill_climbing import HillClimbing\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = HillClimbing(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "L-BFGS",
      "class_name": "LBFGS",
      "category": "classical",
      "category_display": "Classical",
      "slug": "lbfgs",
      "link": "/algorithms/classical/lbfgs",
      "description": "L-BFGS Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per restart."
        },
        {
          "name": "num_restarts",
          "type": "int",
          "default": "25",
          "required": false,
          "description": "Number of random restarts for multistart strategy."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = LBFGS(func=objective_function, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Nelder-Mead",
      "class_name": "NelderMead",
      "category": "classical",
      "category_display": "Classical",
      "slug": "nelder-mead",
      "link": "/algorithms/classical/nelder-mead",
      "description": "Nelder-Mead Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per restart."
        },
        {
          "name": "num_restarts",
          "type": "int",
          "default": "25",
          "required": false,
          "description": "Number of random restarts for multistart strategy."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "optimizer = NelderMead(func=objective_function, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Powell's Method",
      "class_name": "Powell",
      "category": "classical",
      "category_display": "Classical",
      "slug": "powell",
      "link": "/algorithms/classical/powell",
      "description": "Powell Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per restart."
        },
        {
          "name": "num_restarts",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of random restarts."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for BBOB reproducibility."
        }
      ],
      "example_code": "optimizer = Powell(func=objective_function, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Simulated Annealing",
      "class_name": "SimulatedAnnealing",
      "category": "classical",
      "category_display": "Classical",
      "slug": "simulated-annealing",
      "link": "/algorithms/classical/simulated-annealing",
      "description": "Simulated Annealing optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of independent runs."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per run."
        },
        {
          "name": "init_temperature",
          "type": "float",
          "default": "1000",
          "required": false,
          "description": "Initial temperature."
        },
        {
          "name": "stopping_temperature",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Temperature stopping criterion."
        },
        {
          "name": "cooling_rate",
          "type": "float",
          "default": "0.99",
          "required": false,
          "description": "Geometric cooling factor ($0 < \\alpha < 1$)."
        }
      ],
      "example_code": "To use the SimulatedAnnealing optimizer, create an instance of the class and call the `search` method:\n\n    ```python\n    optimizer = SimulatedAnnealing(func, lower_bound, upper_bound, dim)\n    best_solution, best_cost = optimizer.search()\n    ```\n\nClasses:\n    SimulatedAnnealing: A class that implements the Simulated Annealing optimization algorithm."
    },
    {
      "name": "Tabu Search",
      "class_name": "TabuSearch",
      "category": "classical",
      "category_display": "Classical",
      "slug": "tabu",
      "link": "/algorithms/classical/tabu",
      "description": "Tabu Search.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of independent runs."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per run."
        },
        {
          "name": "tabu_list_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Maximum size of tabu memory."
        },
        {
          "name": "neighborhood_size",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of neighbors evaluated per iteration."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for BBOB reproducibility."
        }
      ],
      "example_code": "```python\n    from opt.tabu_search import TabuSearch\n    from opt.benchmark.functions import shifted_ackley\n\n\n    # Define the objective function\n    def objective_function(x):\n        return shifted_ackley(x)\n\n\n    # Create an instance of the TabuSearch optimizer\n    optimizer = TabuSearch(\n        func=objective_function,\n        lower_bound=-32.768,\n        upper_bound=32.768,\n        dim=2,\n        population_size=100,\n        max_iter=1000,\n        tabu_list_size=50,\n        neighborhood_size=10,\n        seed=None,\n    )\n\n    # Run the Tabu Search algorithm\n    best_solution, best_fitness = optimizer.search()\n\n    # Print the best solution and fitness value\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness value: {best_fitness}\")\n    ```"
    },
    {
      "name": "Trust Region",
      "class_name": "TrustRegion",
      "category": "classical",
      "category_display": "Classical",
      "slug": "trust-region",
      "link": "/algorithms/classical/trust-region",
      "description": "Trust Region Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations per restart."
        },
        {
          "name": "num_restarts",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of random restarts."
        },
        {
          "name": "method",
          "type": "str",
          "default": "'trust-constr'",
          "required": false,
          "description": "Trust region variant ('trust-constr', 'trust-exact', 'trust-krylov')."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for BBOB reproducibility."
        }
      ],
      "example_code": "optimizer = TrustRegion(func=objective_function, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Augmented Lagrangian",
      "class_name": "AugmentedLagrangian",
      "category": "constrained",
      "category_display": "Constrained",
      "slug": "augmented-lagrangian",
      "link": "/algorithms/constrained/augmented-lagrangian",
      "description": "Augmented Lagrangian optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum outer iterations."
        },
        {
          "name": "c",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Initial penalty parameter for constraint violations."
        },
        {
          "name": "lambda_",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Initial Lagrange multiplier."
        },
        {
          "name": "static_cost",
          "type": "float",
          "default": "10000000000.0",
          "required": false,
          "description": "Large penalty cost applied when constraint\n        evaluation yields NaN."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.constrained.augmented_lagrangian_method import AugmentedLagrangian\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AugmentedLagrangian(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Barrier Method Optimizer",
      "class_name": "BarrierMethodOptimizer",
      "category": "constrained",
      "category_display": "Constrained",
      "slug": "barrier",
      "link": "/algorithms/constrained/barrier",
      "description": "Barrier Method (Interior Point) Optimizer.",
      "reference": "Boyd, S., & Vandenberghe, L. (2004).\n    Convex Optimization.\n    Cambridge University Press. Chapter 11: Interior-Point Methods.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "constraints",
          "type": "list[Callable[[np.ndarray], float]] | None",
          "default": "None",
          "required": false,
          "description": "List of\n        inequality constraints in form $g(x) \\leq 0$."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum outer iterations."
        },
        {
          "name": "initial_mu",
          "type": "float",
          "default": "10.0",
          "required": false,
          "description": "Starting barrier coefficient."
        },
        {
          "name": "mu_reduction",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Barrier reduction factor \u03b2 (0 < \u03b2 < 1)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import sphere\n# Minimize sphere with constraint x[0] <= 2\ndef constraint(x):\n    return x[0] - 2  # g(x) <= 0 form\noptimizer = BarrierMethodOptimizer(\n    func=sphere,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=2,\n    constraints=[constraint],\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Penalty Method Optimizer",
      "class_name": "PenaltyMethodOptimizer",
      "category": "constrained",
      "category_display": "Constrained",
      "slug": "penalty",
      "link": "/algorithms/constrained/penalty",
      "description": "Penalty Method Optimizer.",
      "reference": "Nocedal, J., & Wright, S. J. (2006).\n    Numerical Optimization (2nd ed.).\n    Springer. Chapter 17: Penalty and Augmented Lagrangian Methods.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "constraints",
          "type": "list[Callable[[np.ndarray], float]] | None",
          "default": "None",
          "required": false,
          "description": "List of\n        inequality constraints in form $g(x) \\leq 0$."
        },
        {
          "name": "eq_constraints",
          "type": "list[Callable[[np.ndarray], float]] | None",
          "default": "None",
          "required": false,
          "description": "List of\n        equality constraints in form $h(x) = 0$."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum outer iterations."
        },
        {
          "name": "initial_penalty",
          "type": "float",
          "default": "1.0",
          "required": false,
          "description": "Starting penalty coefficient \u03c1\u2080."
        },
        {
          "name": "penalty_growth",
          "type": "float",
          "default": "2.0",
          "required": false,
          "description": "Penalty growth factor gamma > 1."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import sphere\n# Minimize sphere with constraint sum(x) >= 0\ndef constraint(x):\n    return -np.sum(x)  # g(x) <= 0 form\noptimizer = PenaltyMethodOptimizer(\n    func=sphere,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=2,\n    constraints=[constraint],\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Sequential Quadratic Programming",
      "class_name": "SequentialQuadraticProgramming",
      "category": "constrained",
      "category_display": "Constrained",
      "slug": "sequential-quadratic-programming",
      "link": "/algorithms/constrained/sequential-quadratic-programming",
      "description": "Sequential Quadratic Programming Optimizer.",
      "reference": "Nocedal, J., & Wright, S. J. (2006).\n    Numerical Optimization (2nd ed.).\n    Springer. Chapter 18: Sequential Quadratic Programming.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "constraints",
          "type": "list[Callable[[np.ndarray], float]] | None",
          "default": "None",
          "required": false,
          "description": "List of\n        inequality constraints in form $g(x) \\leq 0$."
        },
        {
          "name": "eq_constraints",
          "type": "list[Callable[[np.ndarray], float]] | None",
          "default": "None",
          "required": false,
          "description": "List of\n        equality constraints in form $h(x) = 0$."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum SQP iterations."
        },
        {
          "name": "tol",
          "type": "float",
          "default": "1e-06",
          "required": false,
          "description": "Convergence tolerance."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import sphere\n# Minimize sphere with constraint sum(x) = 1\ndef eq_constraint(x):\n    return np.sum(x) - 1\noptimizer = SequentialQuadraticProgramming(\n    func=sphere,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=2,\n    eq_constraints=[eq_constraint],\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Successive Linear Programming",
      "class_name": "SuccessiveLinearProgramming",
      "category": "constrained",
      "category_display": "Constrained",
      "slug": "successive-linear-programming",
      "link": "/algorithms/constrained/successive-linear-programming",
      "description": "Successive Linear Programming optimization algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum SLP iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size for gradient estimation via\n        finite differences."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.constrained.successive_linear_programming import SuccessiveLinearProgramming\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SuccessiveLinearProgramming(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "CMA-ES",
      "class_name": "CMAESAlgorithm",
      "category": "evolutionary",
      "category_display": "Evolutionary",
      "slug": "cma-es",
      "link": "/algorithms/evolutionary/cma-es",
      "description": "Covariance Matrix Adaptation Evolution Strategy.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of offspring per generation (\u03bb)."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "sigma_init",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Initial global step-size controlling search spread."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-09",
          "required": false,
          "description": "Minimum step-size threshold to prevent numerical instability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.evolutionary.cma_es import CMAESAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CMAESAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Cultural Algorithm",
      "class_name": "CulturalAlgorithm",
      "category": "evolutionary",
      "category_display": "Evolutionary",
      "slug": "cultural",
      "link": "/algorithms/evolutionary/cultural",
      "description": "Cultural Algorithm implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of individuals."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "belief_space_size",
          "type": "int",
          "default": "20",
          "required": false,
          "description": "Belief space size."
        },
        {
          "name": "scaling_factor",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Influence strength."
        },
        {
          "name": "mutation_probability",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Mutation probability."
        },
        {
          "name": "elitism",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Elite preservation rate."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.evolutionary.cultural_algorithm import CulturalAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CulturalAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Differential Evolution",
      "class_name": "DifferentialEvolution",
      "category": "evolutionary",
      "category_display": "Evolutionary",
      "slug": "differential-evolution",
      "link": "/algorithms/evolutionary/differential-evolution",
      "description": "Differential Evolution (DE) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of individuals (NP)."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "F",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Mutation factor (differential weight)."
        },
        {
          "name": "CR",
          "type": "float",
          "default": "0.7",
          "required": false,
          "description": "Crossover probability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "optimizer = DifferentialEvolution(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, population_size=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.optimize()"
    },
    {
      "name": "Estimation Of Distribution Algorithm",
      "class_name": "EstimationOfDistributionAlgorithm",
      "category": "evolutionary",
      "category_display": "Evolutionary",
      "slug": "estimation-of-distribution",
      "link": "/algorithms/evolutionary/estimation-of-distribution",
      "description": "Estimation of Distribution Algorithm optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "To use the EstimationOfDistributionAlgorithm optimizer, create an instance of the class\n    and call the search() method:\n\n    ```python\n    optimizer = EstimationOfDistributionAlgorithm(\n        func=shifted_ackley,\n        lower_bound=-32.768,\n        upper_bound=+32.768,\n        dim=2,\n        population_size=100,\n        max_iter=1000,\n    )\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")\n    ```"
    },
    {
      "name": "Genetic Algorithm",
      "class_name": "GeneticAlgorithm",
      "category": "evolutionary",
      "category_display": "Evolutionary",
      "slug": "genetic",
      "link": "/algorithms/evolutionary/genetic",
      "description": "Genetic Algorithm Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "150",
          "required": false,
          "description": "Number of individuals."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations/generations."
        },
        {
          "name": "tournament_size",
          "type": "int",
          "default": "3",
          "required": false,
          "description": "Number of individuals in tournament selection."
        },
        {
          "name": "crossover_rate",
          "type": "float",
          "default": "0.7",
          "required": false,
          "description": "Probability of inheriting from first parent in crossover."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.evolutionary.genetic_algorithm import GeneticAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = GeneticAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Imperialist Competitive Algorithm",
      "class_name": "ImperialistCompetitiveAlgorithm",
      "category": "evolutionary",
      "category_display": "Evolutionary",
      "slug": "imperialist-competitive",
      "link": "/algorithms/evolutionary/imperialist-competitive",
      "description": "Imperialist Competitive Algorithm optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "num_empires",
          "type": "int",
          "default": "15",
          "required": false,
          "description": "Number of initial empires."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Total number of countries."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "revolution_rate",
          "type": "float",
          "default": "0.3",
          "required": false,
          "description": "Revolution probability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "To use this optimizer, create an instance of the `ImperialistCompetitiveAlgorithm` class and call\n    the `search` method to run the optimization.\n\n        from opt.imperialist_competitive_algorithm import ImperialistCompetitiveAlgorithm\n        from opt.benchmark.functions import shifted_ackley\n\n        # Define the objective function\n        def objective_function(x):\n            return shifted_ackley(x)\n\n        # Create an instance of the optimizer\n        optimizer = ImperialistCompetitiveAlgorithm(\n            func=objective_function,\n            dim=2,\n            lower_bound=-32.768,\n            upper_bound=32.768,\n            num_empires=15,\n            population_size=100,\n            max_iter=1000,\n        )\n\n        # Run the optimization\n        best_solution, best_fitness = optimizer.search()\n\n        print(f\"Best solution found: {best_solution}\")\n        print(f\"Best fitness value: {best_fitness}\")"
    },
    {
      "name": "AMSGrad",
      "class_name": "AMSGrad",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "amsgrad",
      "link": "/algorithms/gradient-based/amsgrad",
      "description": "AMSGrad Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "0.001",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "beta1",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Exponential decay rate for first moment estimates."
        },
        {
          "name": "beta2",
          "type": "float",
          "default": "0.999",
          "required": false,
          "description": "Exponential decay rate for second moment estimates."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Small constant for numerical stability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = AMSGrad(func=objective_function, learning_rate=0.001, beta1=0.9, beta2=0.999,\n                       lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Adadelta",
      "class_name": "AdaDelta",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "adadelta",
      "link": "/algorithms/gradient-based/adadelta",
      "description": "AdaDelta Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "rho",
          "type": "float",
          "default": "0.97",
          "required": false,
          "description": "Decay rate for moving averages of squared gradients and updates."
        },
        {
          "name": "eps",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Small constant for numerical stability in division operations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "$ python adadelta.py"
    },
    {
      "name": "Adagrad",
      "class_name": "ADAGrad",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "adagrad",
      "link": "/algorithms/gradient-based/adagrad",
      "description": "ADAGrad Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "lr",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Global learning rate."
        },
        {
          "name": "eps",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Small constant for numerical stability in division operations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = ADAGrad(func=objective_function, learning_rate=0.01, initial_guess=[0, 0])\n    best_solution, best_fitness = optimizer.optimize()"
    },
    {
      "name": "Adam",
      "class_name": "ADAMOptimization",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "adam",
      "link": "/algorithms/gradient-based/adam",
      "description": "Adaptive Moment Estimation (Adam) Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "alpha",
          "type": "float",
          "default": "0.001",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "beta1",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Exponential decay rate for first moment estimates (mean of gradients)."
        },
        {
          "name": "beta2",
          "type": "float",
          "default": "0.999",
          "required": false,
          "description": "Exponential decay rate for second moment estimates (uncentered variance)."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-13",
          "required": false,
          "description": "Small constant for numerical stability in division operations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = Adam(func=objective_function, learning_rate=0.01, initial_guess=[0, 0])\n    best_solution, best_fitness = optimizer.optimize()"
    },
    {
      "name": "AdamW",
      "class_name": "AdamW",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "adamw",
      "link": "/algorithms/gradient-based/adamw",
      "description": "AdamW Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "DEFAULT_MAX_ITERATIONS",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "ADAMW_LEARNING_RATE",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "beta1",
          "type": "float",
          "default": "ADAM_BETA1",
          "required": false,
          "description": "Exponential decay rate for first moment estimates."
        },
        {
          "name": "beta2",
          "type": "float",
          "default": "ADAM_BETA2",
          "required": false,
          "description": "Exponential decay rate for second moment estimates."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "ADAM_EPSILON",
          "required": false,
          "description": "Small constant for numerical stability."
        },
        {
          "name": "weight_decay",
          "type": "float",
          "default": "ADAMW_WEIGHT_DECAY",
          "required": false,
          "description": "Weight decay coefficient for L2 regularization decoupled from gradient."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "optimizer = AdamW(func=objective_function, learning_rate=0.001, beta1=0.9, beta2=0.999,\n                     weight_decay=0.01, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Adamax",
      "class_name": "AdaMax",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "adamax",
      "link": "/algorithms/gradient-based/adamax",
      "description": "AdaMax Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "0.002",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "beta1",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Exponential decay rate for first moment estimates."
        },
        {
          "name": "beta2",
          "type": "float",
          "default": "0.999",
          "required": false,
          "description": "Exponential decay rate for infinity norm."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Small constant for numerical stability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = AdaMax(func=objective_function, learning_rate=0.002, beta1=0.9, beta2=0.999,\n                      lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "NAdam",
      "class_name": "Nadam",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "nadam",
      "link": "/algorithms/gradient-based/nadam",
      "description": "Nadam Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "DEFAULT_MAX_ITERATIONS",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "NADAM_LEARNING_RATE",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "beta1",
          "type": "float",
          "default": "ADAM_BETA1",
          "required": false,
          "description": "Exponential decay rate for first moment estimates."
        },
        {
          "name": "beta2",
          "type": "float",
          "default": "ADAM_BETA2",
          "required": false,
          "description": "Exponential decay rate for second moment estimates."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "ADAM_EPSILON",
          "required": false,
          "description": "Small constant for numerical stability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = Nadam(func=objective_function, learning_rate=0.002, beta1=0.9, beta2=0.999,\n                     lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Nesterov Accelerated Gradient",
      "class_name": "NesterovAcceleratedGradient",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "nesterov",
      "link": "/algorithms/gradient-based/nesterov",
      "description": "Nesterov Accelerated Gradient (NAG) Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "momentum",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Momentum coefficient."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = NesterovAcceleratedGradient(func=objective_function, learning_rate=0.01,\n                                          momentum=0.9, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "RMSprop",
      "class_name": "RMSprop",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "rmsprop",
      "link": "/algorithms/gradient-based/rmsprop",
      "description": "RMSprop Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "rho",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Decay rate for moving average of squared gradients."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Small constant for numerical stability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = RMSprop(func=objective_function, learning_rate=0.01, rho=0.9,\n                       lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "SGD with Momentum",
      "class_name": "SGDMomentum",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "sgd-momentum",
      "link": "/algorithms/gradient-based/sgd-momentum",
      "description": "Stochastic Gradient Descent with Momentum Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "momentum",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Momentum coefficient."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "optimizer = SGDMomentum(func=objective_function, learning_rate=0.01, momentum=0.9,\n                           lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Stochastic Gradient Descent",
      "class_name": "SGD",
      "category": "gradient_based",
      "category_display": "Gradient-Based",
      "slug": "sgd",
      "link": "/algorithms/gradient-based/sgd",
      "description": "Stochastic Gradient Descent (SGD) Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "learning_rate",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Learning rate (step size)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = SGD(func=objective_function, learning_rate=0.01, lower_bound=-5, upper_bound=5, dim=2)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Arithmetic Optimization Algorithm",
      "class_name": "ArithmeticOptimizationAlgorithm",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "arithmetic",
      "link": "/algorithms/metaheuristic/arithmetic",
      "description": "Arithmetic Optimization Algorithm (AOA) implementation.",
      "reference": "Abualigah, L., Diabat, A., Mirjalili, S., Abd Elaziz, M., & Gandomi, A. H.\n    (2021). The arithmetic optimization algorithm. Computer Methods in Applied\n    Mechanics and Engineering, 376, 113609.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Number of candidate solutions."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.metaheuristic.arithmetic_optimization import ArithmeticOptimizationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ArithmeticOptimizationAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Colliding Bodies Optimization",
      "class_name": "CollidingBodiesOptimization",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "colliding-bodies",
      "link": "/algorithms/metaheuristic/colliding-bodies",
      "description": "This module contains the implementation of the Colliding Bodies Optimization algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of bodies."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.metaheuristic.colliding_bodies_optimization import CollidingBodiesOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CollidingBodiesOptimization(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Cross Entropy Method",
      "class_name": "CrossEntropyMethod",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "cross-entropy",
      "link": "/algorithms/metaheuristic/cross-entropy",
      "description": "Cross-Entropy Method (CEM) optimizer implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of samples per iteration."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "elite_frac",
          "type": "float",
          "default": "0.2",
          "required": false,
          "description": "Fraction of samples to use as elite set."
        },
        {
          "name": "noise_decay",
          "type": "float",
          "default": "0.99",
          "required": false,
          "description": "Covariance decay factor to maintain exploration."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.metaheuristic.cross_entropy_method import CrossEntropyMethod\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CrossEntropyMethod(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Eagle Strategy",
      "class_name": "EagleStrategy",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "eagle-strategy",
      "link": "/algorithms/metaheuristic/eagle-strategy",
      "description": "Eagle Strategy Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of eagles."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = EagleStrategy(func=objective_function, lower_bound=-10, upper_bound=10,\n    dim=2, n_eagles=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Forensic Based Investigation Optimizer",
      "class_name": "ForensicBasedInvestigationOptimizer",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "forensic-based-investigation",
      "link": "/algorithms/metaheuristic/forensic-based-investigation",
      "description": "Forensic-Based Investigation Optimization.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Number of investigators."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.metaheuristic.forensic_based import ForensicBasedInvestigationOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ForensicBasedInvestigationOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Harmony Search",
      "class_name": "HarmonySearch",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "harmony",
      "link": "/algorithms/metaheuristic/harmony",
      "description": "Harmony Search (HS) algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Harmony memory size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "harmony_memory_accepting_rate",
          "type": "float",
          "default": "0.95",
          "required": false,
          "description": "Probability of selecting a value\n        from harmony memory (HMCR)."
        },
        {
          "name": "pitch_adjusting_rate",
          "type": "float",
          "default": "0.7",
          "required": false,
          "description": "Probability of adjusting a selected harmony\n        (PAR)."
        },
        {
          "name": "bandwidth",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Range for pitch adjustment."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "optimizer = HarmonySearch(\n        func=shifted_ackley,\n        dim=2,\n        lower_bound=-32.768,\n        upper_bound=+32.768,\n        population_size=100,\n        max_iter=5000,\n    )\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Particle Filter",
      "class_name": "ParticleFilter",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "particle-filter",
      "link": "/algorithms/metaheuristic/particle-filter",
      "description": "Particle Filter Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of particles."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "inertia",
          "type": "float",
          "default": "0.7",
          "required": false,
          "description": "Inertia weight controlling velocity momentum."
        },
        {
          "name": "cognitive",
          "type": "float",
          "default": "1.5",
          "required": false,
          "description": "Cognitive coefficient for personal best attraction."
        },
        {
          "name": "social",
          "type": "float",
          "default": "1.5",
          "required": false,
          "description": "Social coefficient for global best attraction."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "filter = ParticleFilter(func=state_transition_function, initial_state=[0, 0],\n    num_particles=100)\n    next_state = filter.predict()"
    },
    {
      "name": "Shuffled Frog Leaping Algorithm",
      "class_name": "ShuffledFrogLeapingAlgorithm",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "shuffled-frog-leaping",
      "link": "/algorithms/metaheuristic/shuffled-frog-leaping",
      "description": "Shuffled Frog Leaping Algorithm (SFLA) optimizer implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Total number of frogs."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "cut",
          "type": "int",
          "default": "2",
          "required": false,
          "description": "Number of memeplexes (population divisions)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.metaheuristic.shuffled_frog_leaping_algorithm import (\n    ShuffledFrogLeapingAlgorithm,\n)\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ShuffledFrogLeapingAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Sine Cosine Algorithm",
      "class_name": "SineCosineAlgorithm",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "sine-cosine",
      "link": "/algorithms/metaheuristic/sine-cosine",
      "description": "Sine Cosine Algorithm optimization algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of search agents."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "r1_cut",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Threshold for sine/cosine selection."
        },
        {
          "name": "r2_cut",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Threshold for movement direction."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "import numpy as np\n    from opt.benchmark.functions import shifted_ackley\n\n    # Create an instance of SineCosineAlgorithm optimizer\n    optimizer = SineCosineAlgorithm(\n        func=shifted_ackley,\n        dim=2,\n        lower_bound=-32.768,\n        upper_bound=+32.768,\n        population_size=100,\n        max_iter=2000,\n    )\n\n    # Perform the optimization\n    best_solution, best_fitness = optimizer.search()\n\n    # Print the results\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness value: {best_fitness}\")"
    },
    {
      "name": "Stochastic Diffusion Search",
      "class_name": "StochasticDiffusionSearch",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "stochastic-diffusion",
      "link": "/algorithms/metaheuristic/stochastic-diffusion",
      "description": "Stochastic Diffusion Search optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of agents."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.metaheuristic.stochastic_diffusion_search import StochasticDiffusionSearch\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = StochasticDiffusionSearch(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Stochastic Fractal Search",
      "class_name": "StochasticFractalSearch",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "stochastic-fractal",
      "link": "/algorithms/metaheuristic/stochastic-fractal",
      "description": "Stochastic Diffusion Search optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of search particles."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "diffusion_parameter",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Step size for Gaussian diffusion."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "To use the Stochastic Fractal Search optimizer, create an instance of the\n    `StochasticFractalSearch` class and call the `search` method:\n\n    ```python\n    optimizer = StochasticFractalSearch(\n        func=shifted_ackley,\n        dim=2,\n        lower_bound=-32.768,\n        upper_bound=+32.768,\n        population_size=100,\n        max_iter=1000,\n    )\n    best_solution, best_fitness = optimizer.search()\n    ```\n\n    This will return the best solution found and its corresponding fitness value."
    },
    {
      "name": "Variable Depth Search",
      "class_name": "VariableDepthSearch",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "variable-depth",
      "link": "/algorithms/metaheuristic/variable-depth",
      "description": "Variable Depth Search (VDS) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of individuals in population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "max_depth",
          "type": "int",
          "default": "20",
          "required": false,
          "description": "Maximum search depth for neighborhood exploration."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = VariableDepthSearch(\n        func=objective_function,\n        lower_bound=-10,\n        upper_bound=10,\n        dim=2,\n        population_size=100,\n        max_iter=1000,\n        depth=10\n    )\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Variable Neighborhood Search",
      "class_name": "VariableNeighborhoodSearch",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "variable-neighborhood",
      "link": "/algorithms/metaheuristic/variable-neighborhood",
      "description": "Variable Neighborhood Search optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of candidate solutions."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "neighborhood_size",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Maximum neighborhood depth (k_max)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "```python\n    optimizer = VariableNeighborhoodSearch(\n        func=shifted_ackley,\n        dim=2,\n        lower_bound=-32.768,\n        upper_bound=+32.768,\n        population_size=100,\n        max_iter=1000,\n        neighborhood_size=0.1,  # This is the size of the neighborhood for the shaking phase\n    )\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")\n    ```"
    },
    {
      "name": "Very Large Scale Neighborhood",
      "class_name": "VeryLargeScaleNeighborhood",
      "category": "metaheuristic",
      "category_display": "Metaheuristic",
      "slug": "very-large-scale-neighborhood",
      "link": "/algorithms/metaheuristic/very-large-scale-neighborhood",
      "description": "Very Large Scale Neighborhood Search (VLSN) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of individuals in population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "neighborhood_size",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of neighbors explored around each\n        individual."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = VeryLargeScaleNeighborhood(\n        func=objective_function,\n        lower_bound=-10,\n        upper_bound=10,\n        dim=2,\n        population_size=100,\n        max_iter=1000,\n        neighborhood_size=10\n    )\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "MOEA/D",
      "class_name": "MOEAD",
      "category": "multi_objective",
      "category_display": "Multi-Objective",
      "slug": "moead",
      "link": "/algorithms/multi-objective/moead",
      "description": "MOEA/D (Multi-Objective Evolutionary Algorithm based on Decomposition).",
      "reference": "Zhang, Q., & Li, H. (2007).\n    MOEA/D: A multiobjective evolutionary algorithm based on decomposition.\n    IEEE Transactions on Evolutionary Computation, 11(6), 712-731.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "objectives",
          "type": "list[Callable[[np.ndarray], float]]",
          "default": null,
          "required": true,
          "description": "List of objective functions\n        to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of subproblems (weight vectors)."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "300",
          "required": false,
          "description": "Maximum number of generations."
        },
        {
          "name": "n_neighbors",
          "type": "int",
          "default": "20",
          "required": false,
          "description": "Neighborhood size for each subproblem."
        }
      ],
      "example_code": "Basic usage with bi-objective ZDT1 problem:\n\nfrom opt.multi_objective.moead import MOEAD\nimport numpy as np\ndef zdt1_f1(x):\n    return x[0]\ndef zdt1_f2(x):\n    n = len(x)\n    g = 1 + 9 * np.sum(x[1:]) / (n - 1)\n    return g * (1 - np.sqrt(x[0] / g))\noptimizer = MOEAD(\n    objectives=[zdt1_f1, zdt1_f2],\n    lower_bound=0.0,\n    upper_bound=1.0,\n    dim=10,\n    population_size=50,\n    max_iter=10,\n)\n# Note: seed parameter not yet implemented (BBOB compliance gap)\n# For BBOB: would use seed=42 for reproducibility\npareto_front, pareto_set = optimizer.search()\nisinstance(pareto_front, np.ndarray) and len(pareto_front) > 0\n    True\n\n    Multi-objective benchmark example:\n\ndef sphere_obj1(x):\n    return np.sum(x**2)\ndef sphere_obj2(x):\n    return np.sum((x - 2) ** 2)\noptimizer = MOEAD(\n    objectives=[sphere_obj1, sphere_obj2],\n    lower_bound=-5,\n    upper_bound=5,\n    dim=5,\n    max_iter=10,\n)\n# Note: seed=42 would be added here for BBOB compliance\npareto_front, pareto_set = optimizer.search()\npareto_front.shape[1] == 2  # Two objectives\n    True"
    },
    {
      "name": "NSGA-II",
      "class_name": "NSGAII",
      "category": "multi_objective",
      "category_display": "Multi-Objective",
      "slug": "nsga-ii",
      "link": "/algorithms/multi-objective/nsga-ii",
      "description": "NSGA-II: Non-dominated Sorting Genetic Algorithm II.",
      "reference": "Deb, K., Pratap, A., Agarwal, S., & Meyarivan, T. (2002).\n    A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II.\n    IEEE Transactions on Evolutionary Computation, 6(2), 182-197.\n    DOI: 10.1109/4235.996017",
      "reference_doi": "10.1109/4235.996017",
      "parameters": [
        {
          "name": "objectives",
          "type": "Sequence[Callable[[np.ndarray], float]]",
          "default": null,
          "required": true,
          "description": "List of objective functions\n        to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "200",
          "required": false,
          "description": "Maximum number of generations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "**REQUIRED for BBOB compliance."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of individuals in population."
        },
        {
          "name": "crossover_prob",
          "type": "float",
          "default": "_CROSSOVER_PROBABILITY",
          "required": false,
          "description": "SBX crossover probability."
        },
        {
          "name": "mutation_prob",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Polynomial mutation probability per\n        dimension."
        },
        {
          "name": "tournament_size",
          "type": "int",
          "default": "_TOURNAMENT_SIZE",
          "required": false,
          "description": "Binary tournament selection size."
        },
        {
          "name": "eta_c",
          "type": "float",
          "default": "_SBX_DISTRIBUTION_INDEX",
          "required": false,
          "description": "SBX distribution index."
        },
        {
          "name": "eta_m",
          "type": "float",
          "default": "_POLYNOMIAL_MUTATION_INDEX",
          "required": false,
          "description": "Polynomial mutation distribution index."
        }
      ],
      "example_code": "from opt.multi_objective.nsga_ii import NSGAII\nimport numpy as np\ndef f1(x):\n    return sum(x**2)\ndef f2(x):\n    return sum((x - 2) ** 2)\noptimizer = NSGAII(\n    objectives=[f1, f2],\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=100,\n    max_iter=10,\n)\npareto_solutions, pareto_fitness = optimizer.search()\nlen(pareto_solutions) > 0\n    True"
    },
    {
      "name": "SPEA2",
      "class_name": "SPEA2",
      "category": "multi_objective",
      "category_display": "Multi-Objective",
      "slug": "spea2",
      "link": "/algorithms/multi-objective/spea2",
      "description": "SPEA2 (Strength Pareto Evolutionary Algorithm 2) implementation.",
      "reference": "Zitzler, E., Laumanns, M., & Thiele, L. (2001). SPEA2: Improving the\n    strength pareto evolutionary algorithm. TIK-Report 103, ETH Zurich.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "objectives",
          "type": "list[Callable[[np.ndarray], float]]",
          "default": null,
          "required": true,
          "description": "List of objective functions\n        to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum number of generations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of individuals in population."
        },
        {
          "name": "archive_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "External archive size."
        }
      ],
      "example_code": "Basic usage with bi-objective problem:\n\nfrom opt.multi_objective.spea2 import SPEA2\nimport numpy as np\ndef f1(x):\n    return x[0] ** 2 + x[1] ** 2\ndef f2(x):\n    return (x[0] - 1) ** 2 + (x[1] - 1) ** 2\noptimizer = SPEA2(\n    objectives=[f1, f2],\n    lower_bound=-2,\n    upper_bound=2,\n    dim=2,\n    max_iter=10,\n    population_size=50,\n    archive_size=50,\n)\n# Note: seed parameter not yet implemented (BBOB compliance gap)\n# For BBOB: would use seed=42 for reproducibility\npareto_solutions, pareto_objectives = optimizer.search()\nisinstance(pareto_solutions, np.ndarray) and len(pareto_solutions) > 0\n    True\n\n    Multi-objective benchmark example:\n\ndef sphere_obj1(x):\n    return np.sum(x**2)\ndef sphere_obj2(x):\n    return np.sum((x - 2) ** 2)\noptimizer = SPEA2(\n    objectives=[sphere_obj1, sphere_obj2],\n    lower_bound=-5,\n    upper_bound=5,\n    dim=5,\n    max_iter=10,\n    population_size=50,\n    archive_size=50,\n)\n# Note: seed=42 would be added here for BBOB compliance\npareto_solutions, pareto_objectives = optimizer.search()\npareto_objectives.shape[1] == 2  # Two objectives\n    True"
    },
    {
      "name": "Atom Search Optimizer",
      "class_name": "AtomSearchOptimizer",
      "category": "physics_inspired",
      "category_display": "Physics-Inspired",
      "slug": "atom",
      "link": "/algorithms/physics-inspired/atom",
      "description": "Atom Search Optimization (ASO).",
      "reference": "Zhao, W., Wang, L., & Zhang, Z. (2019).\n    Atom search optimization and its application to solve a\n    hydrogeologic parameter estimation problem.\n    Knowledge-Based Systems, 163, 283-304.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size (number of atoms)."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.physics_inspired.atom_search import AtomSearchOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AtomSearchOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Equilibrium Optimizer",
      "class_name": "EquilibriumOptimizer",
      "category": "physics_inspired",
      "category_display": "Physics-Inspired",
      "slug": "equilibrium",
      "link": "/algorithms/physics-inspired/equilibrium",
      "description": "Equilibrium Optimizer (EO).",
      "reference": "Faramarzi, A., Heidarinejad, M., Stephens, B., & Mirjalili, S. (2020).\n    Equilibrium optimizer: A novel optimization algorithm. Knowledge-Based Systems,\n    191, 105190. DOI: 10.1016/j.knosys.2019.105190",
      "reference_doi": "10.1016/j.knosys.2019.105190",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size (number of particles)."
        },
        {
          "name": "a1",
          "type": "float",
          "default": "_A1",
          "required": false,
          "description": "Generation rate control constant."
        },
        {
          "name": "a2",
          "type": "float",
          "default": "_A2",
          "required": false,
          "description": "Time decay exponent for $t$ parameter."
        },
        {
          "name": "gp",
          "type": "float",
          "default": "_GP",
          "required": false,
          "description": "Generation probability threshold."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = EquilibriumOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Gravitational Search Optimizer",
      "class_name": "GravitationalSearchOptimizer",
      "category": "physics_inspired",
      "category_display": "Physics-Inspired",
      "slug": "gravitational",
      "link": "/algorithms/physics-inspired/gravitational",
      "description": "Gravitational Search Algorithm (GSA).",
      "reference": "Rashedi, E., Nezamabadi-Pour, H., & Saryazdi, S. (2009). GSA: A Gravitational\n    Search Algorithm. Information Sciences, 179(13), 2232-2248.\n    DOI: 10.1016/j.ins.2009.03.004",
      "reference_doi": "10.1016/j.ins.2009.03.004",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size (number of agents)."
        },
        {
          "name": "g0",
          "type": "float",
          "default": "_GRAVITATIONAL_CONSTANT_INITIAL",
          "required": false,
          "description": "Initial gravitational constant $G_0$."
        },
        {
          "name": "alpha",
          "type": "float",
          "default": "_GRAVITATIONAL_DECAY_RATE",
          "required": false,
          "description": "Decay rate $\\alpha$ for gravitational constant."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = GravitationalSearchOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "R I M E Optimizer",
      "class_name": "RIMEOptimizer",
      "category": "physics_inspired",
      "category_display": "Physics-Inspired",
      "slug": "r-i-m-e",
      "link": "/algorithms/physics-inspired/r-i-m-e",
      "description": "RIME Optimization Algorithm.",
      "reference": "Su, H., Zhao, D., Heidari, A. A., Liu, L., Zhang, X., Mafarja, M., &\n    Chen, H. (2023).\n    RIME: A physics-based optimization.\n    Neurocomputing, 532, 183-214.\n    DOI: 10.1016/j.neucom.2023.02.010",
      "reference_doi": "10.1016/j.neucom.2023.02.010",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size (number of agents)."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = RIMEOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Adaptive Metropolis Optimizer",
      "class_name": "AdaptiveMetropolisOptimizer",
      "category": "probabilistic",
      "category_display": "Probabilistic",
      "slug": "adaptive-metropolis",
      "link": "/algorithms/probabilistic/adaptive-metropolis",
      "description": "Simulated Annealing with Adaptive Metropolis.",
      "reference": "Haario, H., Saksman, E., & Tamminen, J. (2001).\n    An adaptive Metropolis algorithm.\n    Bernoulli, 7(2), 223-242.\n    DOI: 10.2307/3318737",
      "reference_doi": "10.2307/3318737",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum MCMC iterations."
        },
        {
          "name": "initial_temp",
          "type": "float",
          "default": "10.0",
          "required": false,
          "description": "Starting temperature for annealing schedule."
        },
        {
          "name": "final_temp",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Final temperature for annealing schedule."
        },
        {
          "name": "adaptation_start",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Iteration to start covariance adaptation."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = AdaptiveMetropolisOptimizer(\n    func=shifted_ackley, lower_bound=-2.768, upper_bound=2.768, dim=2, max_iter=1000\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Bayesian Optimizer",
      "class_name": "BayesianOptimizer",
      "category": "probabilistic",
      "category_display": "Probabilistic",
      "slug": "bayesian",
      "link": "/algorithms/probabilistic/bayesian",
      "description": "Bayesian Optimization.",
      "reference": "Snoek, J., Larochelle, H., & Adams, R. P. (2012).\n    Practical Bayesian Optimization of Machine Learning Algorithms.\n    Advances in Neural Information Processing Systems 25 (NIPS 2012).",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "n_initial",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of initial random samples to build GP surrogate."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Maximum Bayesian optimization iterations after initial\n        sampling."
        },
        {
          "name": "xi",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Exploration parameter for Expected Improvement acquisition."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = BayesianOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    n_initial=10,\n    max_iter=50,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "L D Analysis",
      "class_name": "LDAnalysis",
      "category": "probabilistic",
      "category_display": "Probabilistic",
      "slug": "l-d-analysis",
      "link": "/algorithms/probabilistic/l-d-analysis",
      "description": "Linear Discriminant Analysis (LDA).",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of samples for LDA training."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum optimization iterations."
        },
        {
          "name": "number_of_labels",
          "type": "int",
          "default": "20",
          "required": false,
          "description": "Number of discretization bins for fitness values."
        },
        {
          "name": "unique_classes",
          "type": "int",
          "default": "2",
          "required": false,
          "description": "Minimum number of unique classes required for LDA."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "lda = LinearDiscriminantAnalysis(data, target)\n    lda.fit()\n    transformed_data = lda.transform()"
    },
    {
      "name": "Parzen Tree Estimator",
      "class_name": "ParzenTreeEstimator",
      "category": "probabilistic",
      "category_display": "Probabilistic",
      "slug": "parzen-tree-estimator",
      "link": "/algorithms/probabilistic/parzen-tree-estimator",
      "description": "Parzen Tree Estimator optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of observations to maintain for KDE fitting."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum TPE iterations."
        },
        {
          "name": "gamma",
          "type": "float",
          "default": "0.15",
          "required": false,
          "description": "Quantile for splitting observations into good/bad."
        },
        {
          "name": "bandwidth",
          "type": "float",
          "default": "0.2",
          "required": false,
          "description": "Gaussian kernel bandwidth for KDE."
        },
        {
          "name": "n_samples",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Number of candidates to sample from good KDE."
        },
        {
          "name": "selection_strategy",
          "type": "str",
          "default": "'difference'",
          "required": false,
          "description": "Strategy for selecting next point:\n        \"difference\" or \"ratio\"."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.probabilistic.parzen_tree_stimator import ParzenTreeEstimator\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ParzenTreeEstimator(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Sequential Monte Carlo Optimizer",
      "class_name": "SequentialMonteCarloOptimizer",
      "category": "probabilistic",
      "category_display": "Probabilistic",
      "slug": "sequential-monte-carlo",
      "link": "/algorithms/probabilistic/sequential-monte-carlo",
      "description": "Sequential Monte Carlo Optimizer.",
      "reference": "Del Moral, P., Doucet, A., & Jasra, A. (2006).\n    Sequential Monte Carlo Samplers.\n    Journal of the Royal Statistical Society: Series B, 68(3), 411-436.\n    DOI: 10.1111/j.1467-9868.2006.00553.x",
      "reference_doi": "10.1111/j.1467-9868.2006.00553.x",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of particles in SMC population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum SMC iterations."
        },
        {
          "name": "initial_temp",
          "type": "float",
          "default": "10.0",
          "required": false,
          "description": "Starting temperature for importance weighting."
        },
        {
          "name": "final_temp",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Final temperature for importance weighting."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SequentialMonteCarloOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=50,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Political Optimizer",
      "class_name": "PoliticalOptimizer",
      "category": "social_inspired",
      "category_display": "Social-Inspired",
      "slug": "political",
      "link": "/algorithms/social-inspired/political",
      "description": "Political Optimizer Algorithm.",
      "reference": "Askari, Q., Younas, I., & Saeed, M. (2020).\n    Political Optimizer: A novel socio-inspired meta-heuristic for global\n    optimization.\n    Knowledge-Based Systems, 195, 105709.\n    DOI: 10.1016/j.knosys.2020.105709",
      "reference_doi": "10.1016/j.knosys.2020.105709",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Number of politicians in the election."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations (election cycles)."
        },
        {
          "name": "num_parties",
          "type": "int",
          "default": "5",
          "required": false,
          "description": "Number of political parties (clusters)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = PoliticalOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Soccer League Optimizer",
      "class_name": "SoccerLeagueOptimizer",
      "category": "social_inspired",
      "category_display": "Social-Inspired",
      "slug": "soccer-league",
      "link": "/algorithms/social-inspired/soccer-league",
      "description": "Soccer League Competition Algorithm.",
      "reference": "Moosavian, N., & Roodsari, B. K. (2014).\n    Soccer League Competition Algorithm: A novel meta-heuristic algorithm for\n    optimal design of water distribution networks.\n    Swarm and Evolutionary Computation, 17, 14-24.\n    DOI: 10.1016/j.swevo.2014.02.002",
      "reference_doi": "10.1016/j.swevo.2014.02.002",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Total number of teams in the league."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations (seasons)."
        },
        {
          "name": "num_teams",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Number of teams (deprecated, clamped to."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SoccerLeagueOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Social Group Optimizer",
      "class_name": "SocialGroupOptimizer",
      "category": "social_inspired",
      "category_display": "Social-Inspired",
      "slug": "social-group",
      "link": "/algorithms/social-inspired/social-group",
      "description": "Social Group Optimization Algorithm.",
      "reference": "Satapathy, S. C., & Naik, A. (2016).\n    Social group optimization (SGO): A new population evolutionary optimization\n    technique.\n    Complex & Intelligent Systems, 2(3), 173-203.\n    DOI: 10.1007/s40747-016-0022-8",
      "reference_doi": "10.1007/s40747-016-0022-8",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Number of individuals in social group."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "c",
          "type": "float",
          "default": "0.2",
          "required": false,
          "description": "Self-introspection coefficient controlling exploration\n        intensity."
        },
        {
          "name": "track_convergence",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking."
        },
        {
          "name": "early_stopping",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable early stopping when improvement\n        stagnates."
        },
        {
          "name": "tolerance",
          "type": "float",
          "default": "1e-06",
          "required": false,
          "description": "Minimum improvement threshold for early stopping."
        },
        {
          "name": "patience",
          "type": "int",
          "default": "10",
          "required": false,
          "description": "Iterations without improvement before early stopping."
        },
        {
          "name": "verbose",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Print optimization progress."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SocialGroupOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Teaching Learning Optimizer",
      "class_name": "TeachingLearningOptimizer",
      "category": "social_inspired",
      "category_display": "Social-Inspired",
      "slug": "teaching-learning",
      "link": "/algorithms/social-inspired/teaching-learning",
      "description": "Teaching-Learning Based Optimization (TLBO).",
      "reference": "Rao, R. V., Savsani, V. J., & Vakharia, D. P. (2011).\n    Teaching-learning-based optimization: A novel method for constrained\n    mechanical design optimization problems.\n    Computer-Aided Design, 43(3), 303-315.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of learners (students) in the classroom."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations (teaching sessions)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.social_inspired.teaching_learning import TeachingLearningOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = TeachingLearningOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "African Buffalo Optimizer",
      "class_name": "AfricanBuffaloOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "african-buffalo",
      "link": "/algorithms/swarm-intelligence/african-buffalo",
      "description": "African Buffalo Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "lp1",
          "type": "float",
          "default": "_LP1",
          "required": false,
          "description": "Learning parameter 1 controlling exploitation strength."
        },
        {
          "name": "lp2",
          "type": "float",
          "default": "_LP2",
          "required": false,
          "description": "Learning parameter 2 controlling exploration strength."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.african_buffalo_optimization import AfricanBuffaloOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AfricanBuffaloOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "African Vultures Optimizer",
      "class_name": "AfricanVulturesOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "african-vultures",
      "link": "/algorithms/swarm-intelligence/african-vultures",
      "description": "African Vultures Optimization Algorithm (AVOA).",
      "reference": "Abdollahzadeh, B., Soleimanian Gharehchopogh, F., & Mirjalili, S. (2021).\n    African vultures optimization algorithm: A new nature-inspired\n    metaheuristic algorithm for global optimization problems.\n    Computers & Industrial Engineering, 158, 107408.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.african_vultures_optimizer import AfricanVulturesOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AfricanVulturesOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Ant Colony Optimization",
      "class_name": "AntColony",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "ant-colony",
      "link": "/algorithms/swarm-intelligence/ant-colony",
      "description": "Ant Colony Optimization (ACO) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of ants in colony."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "alpha",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Pheromone influence exponent."
        },
        {
          "name": "beta",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Heuristic information weight (not used in basic\n        continuous ACO)."
        },
        {
          "name": "rho",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Pheromone evaporation rate in [0, 1]."
        },
        {
          "name": "q",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Pheromone deposit constant."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = AntColony(func=objective_function, lower_bound=-10, upper_bound=10,\n    dim=2, n_ants=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Ant Lion Optimizer",
      "class_name": "AntLionOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "ant-lion",
      "link": "/algorithms/swarm-intelligence/ant-lion",
      "description": "Ant Lion Optimizer (ALO) Algorithm.",
      "reference": "Mirjalili, S. (2015). The Ant Lion Optimizer.\n    Advances in Engineering Software, 83, 80-98.\n    DOI: 10.1016/j.advengsoft.2015.01.010",
      "reference_doi": "10.1016/j.advengsoft.2015.01.010",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking for BBOB\n        post-processing."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = AntLionOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Aquila Optimizer",
      "class_name": "AquilaOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "aquila",
      "link": "/algorithms/swarm-intelligence/aquila",
      "description": "Aquila Optimizer (AO).",
      "reference": "Abualigah, L., Yousri, D., Abd Elaziz, M., Ewees, A. A., Al-qaness, M. A.,\n    & Gandomi, A. H. (2021). Aquila optimizer: A novel meta-heuristic\n    optimization algorithm.\n    Computers & Industrial Engineering, 157, 107250.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.aquila_optimizer import AquilaOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = AquilaOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Artificial Fish Swarm",
      "class_name": "ArtificialFishSwarm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-fish-swarm",
      "link": "/algorithms/swarm-intelligence/artificial-fish-swarm",
      "description": "Artificial Fish Swarm Algorithm (AFSA).",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "fish_swarm",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of fish in swarm."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "visual",
          "type": "int",
          "default": "1",
          "required": false,
          "description": "Visual distance parameter."
        },
        {
          "name": "step",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Step size parameter."
        },
        {
          "name": "try_number",
          "type": "int",
          "default": "3",
          "required": false,
          "description": "Number of attempts."
        },
        {
          "name": "epsilon",
          "type": "float",
          "default": "1e-09",
          "required": false,
          "description": "Small value for numerical stability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "from opt.artificial_fish_swarm_algorithm import ArtificialFishSwarm\n    optimizer = ArtificialFishSwarm(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, n_fish=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Artificial Gorilla Troops Optimizer",
      "class_name": "ArtificialGorillaTroopsOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-gorilla-troops",
      "link": "/algorithms/swarm-intelligence/artificial-gorilla-troops",
      "description": "Artificial Gorilla Troops Optimizer (GTO).",
      "reference": "Abdollahzadeh, B., Soleimanian Gharehchopogh, F., & Mirjalili, S. (2021).\n    Artificial gorilla troops optimizer: A new nature-inspired metaheuristic\n    algorithm for global optimization problems.\n    International Journal of Intelligent Systems, 36(10), 5887-5958.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "500",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.artificial_gorilla_troops import (\n    ArtificialGorillaTroopsOptimizer,\n)\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ArtificialGorillaTroopsOptimizer(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Artificial Hummingbird Algorithm",
      "class_name": "ArtificialHummingbirdAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-hummingbird",
      "link": "/algorithms/swarm-intelligence/artificial-hummingbird",
      "description": "Artificial Hummingbird Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.artificial_hummingbird import ArtificialHummingbirdAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ArtificialHummingbirdAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Artificial Rabbits Optimizer",
      "class_name": "ArtificialRabbitsOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "artificial-rabbits",
      "link": "/algorithms/swarm-intelligence/artificial-rabbits",
      "description": "Artificial Rabbits Optimization (ARO) Algorithm.",
      "reference": "Wang, L., Cao, Q., Zhang, Z., Mirjalili, S., & Zhao, W. (2022).\n    Artificial rabbits optimization: A new bio-inspired meta-heuristic\n    algorithm for solving engineering optimization problems.\n    Engineering Applications of Artificial Intelligence, 114, 105082.\n    DOI: 10.1016/j.engappai.2022.105082",
      "reference_doi": "10.1016/j.engappai.2022.105082",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = ArtificialRabbitsOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Barnacles Mating Optimizer",
      "class_name": "BarnaclesMatingOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "barnacles-mating",
      "link": "/algorithms/swarm-intelligence/barnacles-mating",
      "description": "Barnacles Mating Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "pl",
          "type": "int",
          "default": "_PL",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.barnacles_mating import BarnaclesMatingOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BarnaclesMatingOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Bat Algorithm",
      "class_name": "BatAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "bat",
      "link": "/algorithms/swarm-intelligence/bat",
      "description": "Bat Algorithm optimization algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "n_bats",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Number of bats in the population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "loudness",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Initial loudness parameter (0-1)."
        },
        {
          "name": "pulse_rate",
          "type": "float",
          "default": "0.9",
          "required": false,
          "description": "Pulse emission rate (0-1)."
        },
        {
          "name": "freq_min",
          "type": "float",
          "default": "0",
          "required": false,
          "description": "Minimum frequency for velocity updates."
        },
        {
          "name": "freq_max",
          "type": "float",
          "default": "2",
          "required": false,
          "description": "Maximum frequency for velocity updates."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "import numpy as np\n    from opt.benchmark.functions import shifted_ackley\n    from opt.bat_algorithm import BatAlgorithm\n\n    # Define the objective function\n    def objective_function(x):\n        return np.sum(x ** 2)\n\n    # Create an instance of the BatAlgorithm class\n    optimizer = BatAlgorithm(\n        func=objective_function,\n        dim=2,\n        lower_bound=-5.0,\n        upper_bound=5.0,\n        n_bats=10,\n        max_iter=1000,\n        loudness=0.5,\n        pulse_rate=0.9,\n        freq_min=0,\n        freq_max=2\n    )\n\n    # Run the Bat Algorithm optimization\n    best_solution, best_fitness = optimizer.search()\n\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness value: {best_fitness}\")"
    },
    {
      "name": "Bee Algorithm",
      "class_name": "BeeAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "bee",
      "link": "/algorithms/swarm-intelligence/bee",
      "description": "Bee Algorithm optimizer implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "n_bees",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of bees in population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "scout_bee",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Scout bee ratio."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.bee_algorithm import BeeAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BeeAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Black Widow Optimizer",
      "class_name": "BlackWidowOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "black-widow",
      "link": "/algorithms/swarm-intelligence/black-widow",
      "description": "Black Widow Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "pp",
          "type": "float",
          "default": "_PP",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "cr",
          "type": "float",
          "default": "_CR",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "pm",
          "type": "float",
          "default": "_PM",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.black_widow import BlackWidowOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BlackWidowOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Brown Bear Optimizer",
      "class_name": "BrownBearOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "brown-bear",
      "link": "/algorithms/swarm-intelligence/brown-bear",
      "description": "Brown Bear Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.brown_bear import BrownBearOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = BrownBearOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Cat Swarm Optimization",
      "class_name": "CatSwarmOptimization",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "cat-swarm",
      "link": "/algorithms/swarm-intelligence/cat-swarm",
      "description": "Cat Swarm Optimization (CSO) algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "cats",
          "type": "int",
          "default": "50",
          "required": false,
          "description": "Number of cats in population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seeking_memory_pool",
          "type": "int",
          "default": "5",
          "required": false,
          "description": "Memory pool size for seeking mode."
        },
        {
          "name": "counts_of_dimension_to_change",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Dimensions to change."
        },
        {
          "name": "smp_change_probability",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "SMP change probability."
        },
        {
          "name": "spc_probability",
          "type": "float",
          "default": "0.2",
          "required": false,
          "description": "SPC probability."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.cat_swarm_optimization import CatSwarmOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CatSwarmOptimization(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Chimp Optimization Algorithm",
      "class_name": "ChimpOptimizationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "chimp",
      "link": "/algorithms/swarm-intelligence/chimp",
      "description": "Chimp Optimization Algorithm (ChOA) implementation.",
      "reference": "Khishe, M., & Mosavi, M. R. (2020). Chimp optimization algorithm.\n    Expert Systems with Applications, 149, 113338.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.chimp_optimization import ChimpOptimizationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ChimpOptimizationAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Coati Optimizer",
      "class_name": "CoatiOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "coati",
      "link": "/algorithms/swarm-intelligence/coati",
      "description": "Coati Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.coati_optimizer import CoatiOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = CoatiOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Cuckoo Search",
      "class_name": "CuckooSearch",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "cuckoo",
      "link": "/algorithms/swarm-intelligence/cuckoo",
      "description": "Cuckoo Search Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of nests (solutions) in the population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "mutation_probability",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Probability of abandoning a nest\n        (discovery rate pa)."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "optimizer = CuckooSearch(func=objective_function, lower_bound=-10, upper_bound=10,\n    dim=2, n_nests=25, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Dandelion Optimizer",
      "class_name": "DandelionOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "dandelion",
      "link": "/algorithms/swarm-intelligence/dandelion",
      "description": "Dandelion Optimizer (DO).",
      "reference": "Zhao, S., Zhang, T., Ma, S., & Chen, M. (2022).\n    Dandelion Optimizer: A nature-inspired metaheuristic algorithm for\n    engineering applications.\n    Engineering Applications of Artificial Intelligence, 114, 105075.\n    DOI: 10.1016/j.engappai.2022.105075",
      "reference_doi": "10.1016/j.engappai.2022.105075",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = DandelionOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Dingo Optimizer",
      "class_name": "DingoOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "dingo",
      "link": "/algorithms/swarm-intelligence/dingo",
      "description": "Dingo Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "survival_rate",
          "type": "float",
          "default": "_SURVIVAL_RATE",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.dingo_optimizer import DingoOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = DingoOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Dragonfly Optimizer",
      "class_name": "DragonflyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "dragonfly",
      "link": "/algorithms/swarm-intelligence/dragonfly",
      "description": "Dragonfly Algorithm (DA).",
      "reference": "Mirjalili, S. (2016). Dragonfly algorithm: a new meta-heuristic optimization\n    technique for solving single-objective, discrete, and multi-objective problems.\n    Neural Computing and Applications, 27(4), 1053-1073.\n    DOI: 10.1007/s00521-015-1920-1",
      "reference_doi": "10.1007/s00521-015-1920-1",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of dragonflies in swarm."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = DragonflyOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Emperor Penguin Optimizer",
      "class_name": "EmperorPenguinOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "emperor-penguin",
      "link": "/algorithms/swarm-intelligence/emperor-penguin",
      "description": "Emperor Penguin Optimizer (EPO) implementation.",
      "reference": "Dhiman, G., & Kumar, V. (2018). Emperor penguin optimizer: A bio-inspired\n    algorithm for engineering problems. Knowledge-Based Systems, 159, 20-50.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.emperor_penguin import EmperorPenguinOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = EmperorPenguinOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Fennec Fox Optimizer",
      "class_name": "FennecFoxOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "fennec-fox",
      "link": "/algorithms/swarm-intelligence/fennec-fox",
      "description": "Fennec Fox Optimization (FFO) Algorithm.",
      "reference": "Trojovsk\u00e1, E., Dehghani, M., & Trojovsk\u00fd, P. (2023).\n    Fennec Fox Optimization: A New Nature-Inspired Optimization Algorithm.\n    IEEE Access, 10, 84417-84443.\n    DOI: 10.1109/ACCESS.2022.3197745",
      "reference_doi": "10.1109/ACCESS.2022.3197745",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = FennecFoxOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Firefly Algorithm",
      "class_name": "FireflyAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "firefly",
      "link": "/algorithms/swarm-intelligence/firefly",
      "description": "Firefly Algorithm implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of fireflies in the population."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "alpha",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Randomization parameter controlling step size\n        of random movement."
        },
        {
          "name": "beta_0",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Attractiveness coefficient at distance r=0."
        },
        {
          "name": "gamma",
          "type": "float",
          "default": "1",
          "required": false,
          "description": "Light absorption coefficient."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.firefly_algorithm import FireflyAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = FireflyAlgorithm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Flower Pollination Algorithm",
      "class_name": "FlowerPollinationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "flower-pollination",
      "link": "/algorithms/swarm-intelligence/flower-pollination",
      "description": "Flower Pollination Algorithm (FPA) implementation.",
      "reference": "Yang, X.-S. (2012). Flower pollination algorithm for global optimization.\n    In Unconventional Computation and Natural Computation (pp. 240-249).\n    Springer.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "25",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "switch_probability",
          "type": "float",
          "default": "_SWITCH_PROBABILITY",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.flower_pollination import FlowerPollinationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = FlowerPollinationAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Giant Trevally Optimizer",
      "class_name": "GiantTrevallyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "giant-trevally",
      "link": "/algorithms/swarm-intelligence/giant-trevally",
      "description": "Giant Trevally Optimizer (GTO).",
      "reference": "Sadeeq, H. T., & Abdulazeez, A. M. (2022).\n    Giant Trevally Optimizer (GTO): A Novel Metaheuristic Algorithm for\n    Global Optimization and Challenging Engineering Problems.\n    IEEE Access, 10, 121615-121640.\n    DOI: 10.1109/ACCESS.2022.3223388",
      "reference_doi": "10.1109/ACCESS.2022.3223388",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = GiantTrevallyOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Glowworm Swarm Optimization",
      "class_name": "GlowwormSwarmOptimization",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "glowworm-swarm",
      "link": "/algorithms/swarm-intelligence/glowworm-swarm",
      "description": "Glowworm Swarm Optimization (GSO) algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of glowworms."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "luciferin_decay",
          "type": "float",
          "default": "0.1",
          "required": false,
          "description": "Luciferin decay constant."
        },
        {
          "name": "randomness",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Randomness factor in movement."
        },
        {
          "name": "step_size",
          "type": "float",
          "default": "0.01",
          "required": false,
          "description": "Movement step size."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.glowworm_swarm_optimization import GlowwormSwarmOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = GlowwormSwarmOptimization(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Golden Eagle Optimizer",
      "class_name": "GoldenEagleOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "golden-eagle",
      "link": "/algorithms/swarm-intelligence/golden-eagle",
      "description": "Golden Eagle Optimizer (GEO) implementation.",
      "reference": "Mohammadi-Balani, A., Nayeri, M. D., Azar, A., & Taghizadeh-Yazdi, M.\n    (2021). Golden eagle optimizer: A nature-inspired metaheuristic algorithm.\n    Computers & Industrial Engineering, 152, 107050.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.golden_eagle import GoldenEagleOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = GoldenEagleOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Grasshopper Optimizer",
      "class_name": "GrasshopperOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "grasshopper",
      "link": "/algorithms/swarm-intelligence/grasshopper",
      "description": "Grasshopper Optimization Algorithm (GOA).",
      "reference": "Saremi, S., Mirjalili, S., & Lewis, A. (2017). Grasshopper Optimisation\n    Algorithm: Theory and application. Advances in Engineering Software,\n    105, 30-47. DOI: 10.1016/j.advengsoft.2017.01.004",
      "reference_doi": "10.1016/j.advengsoft.2017.01.004",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of grasshoppers."
        },
        {
          "name": "c_max",
          "type": "float",
          "default": "_C_MAX",
          "required": false,
          "description": "Maximum coefficient for social forces."
        },
        {
          "name": "c_min",
          "type": "float",
          "default": "_C_MIN",
          "required": false,
          "description": "Minimum coefficient for social forces."
        },
        {
          "name": "f",
          "type": "float",
          "default": "_ATTRACTION_INTENSITY",
          "required": false,
          "description": "Attraction intensity in social force function."
        },
        {
          "name": "l",
          "type": "float",
          "default": "_ATTRACTIVE_LENGTH_SCALE",
          "required": false,
          "description": "Attractive length scale in social force function."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = GrasshopperOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Grey Wolf Optimizer",
      "class_name": "GreyWolfOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "grey-wolf",
      "link": "/algorithms/swarm-intelligence/grey-wolf",
      "description": "Grey Wolf Optimizer (GWO) Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Pack size (number of wolves)."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = GreyWolfOptimizer(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, pack_size=20, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()\n    print(f\"Best solution found: {best_solution}\")\n    print(f\"Best fitness found: {best_fitness}\")"
    },
    {
      "name": "Harris Hawks Optimizer",
      "class_name": "HarrisHawksOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "harris-hawks",
      "link": "/algorithms/swarm-intelligence/harris-hawks",
      "description": "Harris Hawks Optimization (HHO) Algorithm.",
      "reference": "Heidari, A.A., Mirjalili, S., Faris, H., Aljarah, I., Mafarja, M., & Chen, H.\n    (2019). Harris hawks optimization: Algorithm and applications.\n    Future Generation Computer Systems, 97, 849-872.\n    DOI: 10.1016/j.future.2019.02.028",
      "reference_doi": "10.1016/j.future.2019.02.028",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of hawks."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = HarrisHawksOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Honey Badger Algorithm",
      "class_name": "HoneyBadgerAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "honey-badger",
      "link": "/algorithms/swarm-intelligence/honey-badger",
      "description": "Honey Badger Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "beta",
          "type": "float",
          "default": "_BETA",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.honey_badger import HoneyBadgerAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = HoneyBadgerAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Manta Ray Foraging Optimization",
      "class_name": "MantaRayForagingOptimization",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "manta-ray-foraging",
      "link": "/algorithms/swarm-intelligence/manta-ray-foraging",
      "description": "Manta Ray Foraging Optimization (MRFO) implementation.",
      "reference": "Zhao, W., Zhang, Z., & Wang, L. (2020). Manta ray foraging optimization:\n    An effective bio-inspired optimizer for engineering applications.\n    Engineering Applications of Artificial Intelligence, 87, 103300.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.manta_ray import MantaRayForagingOptimization\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MantaRayForagingOptimization(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Marine Predators Optimizer",
      "class_name": "MarinePredatorsOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "marine-predators",
      "link": "/algorithms/swarm-intelligence/marine-predators",
      "description": "Marine Predators Algorithm (MPA).",
      "reference": "Faramarzi, A., Heidarinejad, M., Mirjalili, S., & Gandomi, A. H. (2020).\n    Marine Predators Algorithm: A nature-inspired metaheuristic.\n    Expert Systems with Applications, 152, 113377.\n    DOI: 10.1016/j.eswa.2020.113377",
      "reference_doi": "10.1016/j.eswa.2020.113377",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of predators/prey."
        },
        {
          "name": "fads",
          "type": "float",
          "default": "_FADs_EFFECT_PROB",
          "required": false,
          "description": "Fish Aggregating Devices effect probability."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = MarinePredatorsOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Mayfly Optimizer",
      "class_name": "MayflyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "mayfly",
      "link": "/algorithms/swarm-intelligence/mayfly",
      "description": "Mayfly Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "a1",
          "type": "float",
          "default": "_A1",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "a2",
          "type": "float",
          "default": "_A2",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "a3",
          "type": "float",
          "default": "_A3",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "beta",
          "type": "float",
          "default": "_BETA",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "dance",
          "type": "float",
          "default": "_DANCE",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "fl",
          "type": "float",
          "default": "_FL",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "g",
          "type": "float",
          "default": "_G",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.mayfly_optimizer import MayflyOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MayflyOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Moth Flame Optimizer",
      "class_name": "MothFlameOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "moth-flame",
      "link": "/algorithms/swarm-intelligence/moth-flame",
      "description": "Moth-Flame Optimization (MFO) Algorithm.",
      "reference": "Mirjalili, S. (2015). Moth-flame optimization algorithm: A novel nature-inspired\n    heuristic paradigm. Knowledge-Based Systems, 89, 228-249.\n    DOI: 10.1016/j.knosys.2015.07.006",
      "reference_doi": "10.1016/j.knosys.2015.07.006",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of moths/flames."
        },
        {
          "name": "b",
          "type": "float",
          "default": "1.0",
          "required": false,
          "description": "Spiral shape constant."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = MothFlameOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Moth Search Algorithm",
      "class_name": "MothSearchAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "moth",
      "link": "/algorithms/swarm-intelligence/moth",
      "description": "Moth Search Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "path_finder_ratio",
          "type": "float",
          "default": "0.5",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.moth_search import MothSearchAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MothSearchAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Mountain Gazelle Optimizer",
      "class_name": "MountainGazelleOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "mountain-gazelle",
      "link": "/algorithms/swarm-intelligence/mountain-gazelle",
      "description": "Mountain Gazelle Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.mountain_gazelle import MountainGazelleOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = MountainGazelleOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Orca Predator Algorithm",
      "class_name": "OrcaPredatorAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "orca-predator",
      "link": "/algorithms/swarm-intelligence/orca-predator",
      "description": "Orca Predator Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.orca_predator import OrcaPredatorAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = OrcaPredatorAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Osprey Optimizer",
      "class_name": "OspreyOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "osprey",
      "link": "/algorithms/swarm-intelligence/osprey",
      "description": "Osprey Optimization Algorithm (OOA).",
      "reference": "Dehghani, M., Trojovsk\u00fd, P., & Hub\u00e1lovsk\u00fd, \u0160. (2023).\n    Osprey optimization algorithm: A new bio-inspired metaheuristic algorithm\n    for solving engineering optimization problems.\n    Frontiers in Mechanical Engineering, 8, 1126450.\n    DOI: 10.3389/fmech.2022.1126450",
      "reference_doi": "10.3389/fmech.2022.1126450",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = OspreyOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Particle Swarm Optimization",
      "class_name": "ParticleSwarm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "particle-swarm",
      "link": "/algorithms/swarm-intelligence/particle-swarm",
      "description": "Particle Swarm Optimization (PSO) algorithm implementation.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "DEFAULT_POPULATION_SIZE",
          "required": false,
          "description": "Number of particles in swarm."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "DEFAULT_MAX_ITERATIONS",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "c1",
          "type": "float",
          "default": "PSO_COGNITIVE_COEFFICIENT",
          "required": false,
          "description": "Cognitive coefficient controlling attraction to personal\n        best."
        },
        {
          "name": "c2",
          "type": "float",
          "default": "PSO_SOCIAL_COEFFICIENT",
          "required": false,
          "description": "Social coefficient controlling attraction to global best."
        },
        {
          "name": "w",
          "type": "float",
          "default": "PSO_INERTIA_WEIGHT",
          "required": false,
          "description": "Inertia weight controlling previous velocity influence."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking for BBOB\n        post-processing."
        },
        {
          "name": "target_precision",
          "type": "float",
          "default": "1e-08",
          "required": false,
          "description": "Algorithm-specific parameter"
        },
        {
          "name": "f_opt",
          "type": "float | None",
          "default": "None",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.particle_swarm import ParticleSwarm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ParticleSwarm(\n    func=shifted_ackley,\n    lower_bound=-32.768,\n    upper_bound=32.768,\n    dim=2,\n    max_iter=50,\n    seed=42,\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Pathfinder Algorithm",
      "class_name": "PathfinderAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "pathfinder",
      "link": "/algorithms/swarm-intelligence/pathfinder",
      "description": "Pathfinder Algorithm (PFA) implementation.",
      "reference": "Yapici, H., & Cetinkaya, N. (2019). A new meta-heuristic optimizer:\n    Pathfinder algorithm. Applied Soft Computing, 78, 545-568.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.pathfinder import PathfinderAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = PathfinderAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Pelican Optimizer",
      "class_name": "PelicanOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "pelican",
      "link": "/algorithms/swarm-intelligence/pelican",
      "description": "Pelican Optimization Algorithm (POA).",
      "reference": "Trojovsk\u00fd, P., & Dehghani, M. (2022).\n    Pelican Optimization Algorithm: A Novel Nature-Inspired Algorithm for\n    Engineering Applications.\n    Sensors, 22(3), 855.\n    DOI: 10.3390/s22030855",
      "reference_doi": "10.3390/s22030855",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = PelicanOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Reptile Search Algorithm",
      "class_name": "ReptileSearchAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "reptile",
      "link": "/algorithms/swarm-intelligence/reptile",
      "description": "Reptile Search Algorithm (RSA) implementation.",
      "reference": "Abualigah, L., Abd Elaziz, M., Sumari, P., Geem, Z. W., & Gandomi, A. H.\n    (2022). Reptile Search Algorithm (RSA): A nature-inspired meta-heuristic\n    optimizer. Expert Systems with Applications, 191, 116158.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.reptile_search import ReptileSearchAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = ReptileSearchAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Salp Swarm Optimizer",
      "class_name": "SalpSwarmOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "salp-swarm",
      "link": "/algorithms/swarm-intelligence/salp-swarm",
      "description": "Salp Swarm Algorithm (SSA).",
      "reference": "Mirjalili, S., Gandomi, A. H., Mirjalili, S. Z., Saremi, S., Faris, H., &\n    Mirjalili, S. M. (2017). Salp Swarm Algorithm: A bio-inspired optimizer for\n    engineering design problems. Advances in Engineering Software, 114, 163-191.\n    DOI: 10.1016/j.advengsoft.2017.07.002",
      "reference_doi": "10.1016/j.advengsoft.2017.07.002",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of salps in the chain."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SalpSwarmOptimizer(\n    func=shifted_ackley,\n    lower_bound=-5,\n    upper_bound=5,\n    dim=10,\n    population_size=30,\n    max_iter=500,\n)\nbest_solution, best_fitness = optimizer.search()\nisinstance(float(best_fitness), float)\n    True"
    },
    {
      "name": "Sand Cat Swarm Optimizer",
      "class_name": "SandCatSwarmOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "sand-cat-swarm",
      "link": "/algorithms/swarm-intelligence/sand-cat-swarm",
      "description": "Sand Cat Swarm Optimization Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.sand_cat import SandCatSwarmOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SandCatSwarmOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Seagull Optimization Algorithm",
      "class_name": "SeagullOptimizationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "seagull",
      "link": "/algorithms/swarm-intelligence/seagull",
      "description": "Seagull Optimization Algorithm (SOA) implementation.",
      "reference": "Dhiman, G., & Kumar, V. (2019). Seagull optimization algorithm: Theory\n    and its applications for large-scale industrial engineering problems.\n    Knowledge-Based Systems, 165, 169-196.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.seagull_optimization import SeagullOptimizationAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SeagullOptimizationAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Slime Mould Algorithm",
      "class_name": "SlimeMouldAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "slime-mould",
      "link": "/algorithms/swarm-intelligence/slime-mould",
      "description": "Slime Mould Algorithm (SMA) implementation.",
      "reference": "Li, S., Chen, H., Wang, M., Heidari, A. A., & Mirjalili, S. (2020).\n    Slime mould algorithm: A new method for stochastic optimization.\n    Future Generation Computer Systems, 111, 300-323.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.slime_mould import SlimeMouldAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SlimeMouldAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Snow Geese Optimizer",
      "class_name": "SnowGeeseOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "snow-geese",
      "link": "/algorithms/swarm-intelligence/snow-geese",
      "description": "Snow Geese Optimization Algorithm (SGOA).",
      "reference": "Jiang, H., Yang, Y., Ping, W., & Dong, Y. (2023).\n    A novel hybrid algorithm based on Snow Geese and Differential Evolution\n    for global optimization.\n    Applied Soft Computing, 139, 110235.\n    DOI: 10.1016/j.asoc.2023.110235",
      "reference_doi": "10.1016/j.asoc.2023.110235",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = SnowGeeseOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Spotted Hyena Optimizer",
      "class_name": "SpottedHyenaOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "spotted-hyena",
      "link": "/algorithms/swarm-intelligence/spotted-hyena",
      "description": "Spotted Hyena Optimizer (SHO) implementation.",
      "reference": "Dhiman, G., & Kumar, V. (2017). Spotted hyena optimizer: A novel\n    bio-inspired based metaheuristic technique for engineering applications.\n    Advances in Engineering Software, 114, 48-70.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.spotted_hyena import SpottedHyenaOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SpottedHyenaOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Squirrel Search Algorithm",
      "class_name": "SquirrelSearchAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "squirrel",
      "link": "/algorithms/swarm-intelligence/squirrel",
      "description": "Squirrel Search Algorithm.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Enable convergence history tracking for BBOB\n        post-processing."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.squirrel_search import SquirrelSearchAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = SquirrelSearchAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Starling Murmuration Optimizer",
      "class_name": "StarlingMurmurationOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "starling-murmuration",
      "link": "/algorithms/swarm-intelligence/starling-murmuration",
      "description": "Starling Murmuration Optimizer (SMO).",
      "reference": "Zamani, H., Nadimi-Shahraki, M. H., & Gandomi, A. H. (2022).\n    Starling murmuration optimizer: A novel bio-inspired algorithm for\n    global and engineering optimization.\n    Computer Methods in Applied Mechanics and Engineering, 392, 114616.\n    DOI: 10.1016/j.cma.2022.114616",
      "reference_doi": "10.1016/j.cma.2022.114616",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = StarlingMurmurationOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Tunicate Swarm Algorithm",
      "class_name": "TunicateSwarmAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "tunicate-swarm",
      "link": "/algorithms/swarm-intelligence/tunicate-swarm",
      "description": "Tunicate Swarm Algorithm (TSA) implementation.",
      "reference": "Kaur, S., Awasthi, L. K., Sangal, A. L., & Dhiman, G. (2020). Tunicate\n    Swarm Algorithm: A new bio-inspired based metaheuristic paradigm for\n    global optimization. Engineering Applications of Artificial Intelligence,\n    90, 103541.",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.tunicate_swarm import TunicateSwarmAlgorithm\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = TunicateSwarmAlgorithm(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Whale Optimization Algorithm",
      "class_name": "WhaleOptimizationAlgorithm",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "whale",
      "link": "/algorithms/swarm-intelligence/whale",
      "description": "Whale Optimization Algorithm (WOA).",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "1000",
          "required": false,
          "description": "Maximum iterations."
        },
        {
          "name": "seed",
          "type": "int | None",
          "default": "None",
          "required": false,
          "description": "Random seed for reproducibility."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Number of whales."
        },
        {
          "name": "track_history",
          "type": "bool",
          "default": "False",
          "required": false,
          "description": "Track optimization history for visualization"
        }
      ],
      "example_code": "optimizer = WhaleOptimizationAlgorithm(func=objective_function, lower_bound=-10,\n    upper_bound=10, dim=2, n_whales=50, max_iter=1000)\n    best_solution, best_fitness = optimizer.search()"
    },
    {
      "name": "Wild Horse Optimizer",
      "class_name": "WildHorseOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "wild-horse",
      "link": "/algorithms/swarm-intelligence/wild-horse",
      "description": "Wild Horse Optimizer.",
      "reference": "",
      "reference_doi": "",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Maximum iterations."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "n_groups",
          "type": "int",
          "default": "5",
          "required": false,
          "description": "Algorithm-specific parameter"
        }
      ],
      "example_code": "Basic usage with BBOB benchmark function:\n\nfrom opt.swarm_intelligence.wild_horse import WildHorseOptimizer\nfrom opt.benchmark.functions import shifted_ackley\noptimizer = WildHorseOptimizer(\n    func=shifted_ackley, lower_bound=-32.768, upper_bound=32.768, dim=2, max_iter=50\n)\nsolution, fitness = optimizer.search()\nisinstance(fitness, float)\n    True\nlen(solution) == 2\n    True\n\n    For COCO/BBOB benchmarking with full statistical analysis,\n    see `benchmarks/run_benchmark_suite.py`."
    },
    {
      "name": "Zebra Optimizer",
      "class_name": "ZebraOptimizer",
      "category": "swarm_intelligence",
      "category_display": "Swarm Intelligence",
      "slug": "zebra",
      "link": "/algorithms/swarm-intelligence/zebra",
      "description": "Zebra Optimization Algorithm (ZOA).",
      "reference": "Trojovsk\u00e1, E., Dehghani, M., & Trojovsk\u00fd, P. (2022).\n    Zebra Optimization Algorithm: A New Bio-Inspired Optimization Algorithm\n    for Solving Optimization Problems.\n    IEEE Access, 10, 49445-49473.\n    DOI: 10.1109/ACCESS.2022.3172789",
      "reference_doi": "10.1109/ACCESS.2022.3172789",
      "parameters": [
        {
          "name": "func",
          "type": "Callable[[np.ndarray], float]",
          "default": null,
          "required": true,
          "description": "Objective function to minimize."
        },
        {
          "name": "lower_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Lower bound of search space."
        },
        {
          "name": "upper_bound",
          "type": "float",
          "default": null,
          "required": true,
          "description": "Upper bound of search space."
        },
        {
          "name": "dim",
          "type": "int",
          "default": null,
          "required": true,
          "description": "Problem dimensionality."
        },
        {
          "name": "population_size",
          "type": "int",
          "default": "30",
          "required": false,
          "description": "Population size."
        },
        {
          "name": "max_iter",
          "type": "int",
          "default": "100",
          "required": false,
          "description": "Maximum iterations."
        }
      ],
      "example_code": "from opt.benchmark.functions import shifted_ackley\noptimizer = ZebraOptimizer(\n    func=shifted_ackley,\n    lower_bound=-2.768,\n    upper_bound=2.768,\n    dim=2,\n    population_size=30,\n    max_iter=100,\n)\nbest_solution, best_fitness = optimizer.search()"
    }
  ]
}