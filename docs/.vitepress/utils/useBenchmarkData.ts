/**
 * Vue composable for loading and managing benchmark data
 */

import { ref, computed } from 'vue'
import type { Ref } from 'vue'
import type { BenchmarkDataSchema, Benchmarks } from './types'

/**
 * Composable for loading benchmark data from JSON files
 * 
 * Usage:
 *   const { data, loading, error } = useBenchmarkData('shifted_ackley', 2, ['ParticleSwarm', 'DifferentialEvolution'])
 */
export function useBenchmarkData(
  functionName: string,
  dimension: number,
  optimizers?: string[]
) {
  const data = ref<BenchmarkDataSchema | null>(null)
  const loading = ref(true)
  const error = ref<string | null>(null)

  // Load the main benchmark data file
  const loadData = async () => {
    try {
      loading.value = true
      error.value = null

      // Try to load from the benchmarks directory
      // In production, this would be generated by CI
      const response = await fetch('/benchmarks/benchmark-results.json')
      
      if (!response.ok) {
        // Fallback to test data if benchmarks don't exist yet
        const testResponse = await fetch('/test-data/mock-benchmark-data.json')
        if (!testResponse.ok) {
          throw new Error('Failed to load benchmark data')
        }
        data.value = await testResponse.json()
      } else {
        data.value = await response.json()
      }
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'Unknown error loading data'
      console.error('Error loading benchmark data:', e)
    } finally {
      loading.value = false
    }
  }

  // Filter data for specific function and dimension
  const filteredData = computed(() => {
    if (!data.value) return null

    const funcData = data.value.benchmarks[functionName]
    if (!funcData) return null

    const dimData = funcData[dimension.toString()]
    if (!dimData) return null

    // If specific optimizers are requested, filter them
    if (optimizers && optimizers.length > 0) {
      const filtered: Record<string, Benchmarks> = {}
      for (const opt of optimizers) {
        if (dimData[opt]) {
          filtered[opt] = dimData[opt]
        }
      }
      return filtered
    }

    return dimData
  })

  // Metadata from the benchmark suite
  const metadata = computed(() => data.value?.metadata ?? null)

  // Available functions in the dataset
  const availableFunctions = computed(() => 
    data.value ? Object.keys(data.value.benchmarks) : []
  )

  // Available dimensions for a specific function
  const availableDimensions = computed(() => {
    if (!data.value || !functionName) return []
    const funcData = data.value.benchmarks[functionName]
    return funcData ? Object.keys(funcData).map(Number) : []
  })

  // Available optimizers for a specific function and dimension
  const availableOptimizers = computed(() => {
    if (!data.value || !functionName) return []
    const funcData = data.value.benchmarks[functionName]
    if (!funcData) return []
    const dimData = funcData[dimension.toString()]
    return dimData ? Object.keys(dimData) : []
  })

  // Load data on mount
  loadData()

  return {
    data: filteredData,
    metadata,
    loading,
    error,
    availableFunctions,
    availableDimensions,
    availableOptimizers,
    reload: loadData
  }
}

/**
 * Simpler composable that loads data synchronously from a known path
 * Useful for static site generation
 */
export function useBenchmarkDataSync(filePath: string = '/test-data/mock-benchmark-data.json') {
  const data = ref<BenchmarkDataSchema | null>(null)
  const loading = ref(true)
  const error = ref<string | null>(null)

  const loadData = async () => {
    try {
      loading.value = true
      error.value = null
      const response = await fetch(filePath)
      if (!response.ok) {
        throw new Error(`Failed to load data from ${filePath}`)
      }
      data.value = await response.json()
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'Unknown error'
      console.error('Error loading benchmark data:', e)
    } finally {
      loading.value = false
    }
  }

  loadData()

  return {
    data,
    loading,
    error,
    reload: loadData
  }
}
